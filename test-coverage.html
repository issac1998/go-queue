
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/issac1998/go-queue/client/admin.go (71.1%)</option>
				
				<option value="file1">github.com/issac1998/go-queue/client/client.go (40.6%)</option>
				
				<option value="file2">github.com/issac1998/go-queue/client/consumer.go (52.5%)</option>
				
				<option value="file3">github.com/issac1998/go-queue/client/consumer_group.go (0.0%)</option>
				
				<option value="file4">github.com/issac1998/go-queue/client/producer.go (65.4%)</option>
				
				<option value="file5">github.com/issac1998/go-queue/cmd/broker/main.go (0.0%)</option>
				
				<option value="file6">github.com/issac1998/go-queue/cmd/client/main.go (0.0%)</option>
				
				<option value="file7">github.com/issac1998/go-queue/examples/compression_dedup/main.go (0.0%)</option>
				
				<option value="file8">github.com/issac1998/go-queue/examples/consumer_groups/main.go (0.0%)</option>
				
				<option value="file9">github.com/issac1998/go-queue/examples/simple/main.go (0.0%)</option>
				
				<option value="file10">github.com/issac1998/go-queue/internal/cluster/manager.go (0.0%)</option>
				
				<option value="file11">github.com/issac1998/go-queue/internal/cluster/statemachine.go (0.0%)</option>
				
				<option value="file12">github.com/issac1998/go-queue/internal/compression/compression.go (0.0%)</option>
				
				<option value="file13">github.com/issac1998/go-queue/internal/config/config.go (0.0%)</option>
				
				<option value="file14">github.com/issac1998/go-queue/internal/deduplication/deduplication.go (0.0%)</option>
				
				<option value="file15">github.com/issac1998/go-queue/internal/metadata/consumer_group.go (0.6%)</option>
				
				<option value="file16">github.com/issac1998/go-queue/internal/metadata/manager.go (36.1%)</option>
				
				<option value="file17">github.com/issac1998/go-queue/internal/metadata/topic.go (56.1%)</option>
				
				<option value="file18">github.com/issac1998/go-queue/internal/protocol/consumer_group.go (0.0%)</option>
				
				<option value="file19">github.com/issac1998/go-queue/internal/protocol/fetch.go (0.0%)</option>
				
				<option value="file20">github.com/issac1998/go-queue/internal/protocol/produce.go (0.0%)</option>
				
				<option value="file21">github.com/issac1998/go-queue/internal/storage/segment.go (65.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "bytes"
        "encoding/binary"
        "fmt"
)

// Admin management client
type Admin struct {
        client *Client
}

// NewAdmin creates a new admin client
func NewAdmin(client *Client) *Admin <span class="cov10" title="5">{
        return &amp;Admin{
                client: client,
        }
}</span>

// CreateTopicRequest create topic request
type CreateTopicRequest struct {
        Name       string
        Partitions int32
        Replicas   int32 // Not supported yet, set to 1
}

// CreateTopicResult create topic result
type CreateTopicResult struct {
        Name  string
        Error error
}

// CreateTopic creates a topic
func (a *Admin) CreateTopic(req CreateTopicRequest) (*CreateTopicResult, error) <span class="cov7" title="3">{
        if req.Partitions &lt;= 0 </span><span class="cov4" title="2">{
                req.Partitions = 1
        }</span>
        <span class="cov7" title="3">if req.Replicas &lt;= 0 </span><span class="cov1" title="1">{
                req.Replicas = 1
        }</span>

        <span class="cov7" title="3">requestData, err := a.buildCreateTopicRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build request: %v", err)
        }</span>

        <span class="cov7" title="3">responseData, err := a.client.sendRequest(CreateTopicRequestType, requestData)
        if err != nil </span><span class="cov7" title="3">{
                return nil, fmt.Errorf("failed to send request: %v", err)
        }</span>

        <span class="cov0" title="0">result, err := a.parseCreateTopicResponse(req.Name, responseData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %v", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// buildCreateTopicRequest builds create topic request
func (a *Admin) buildCreateTopicRequest(req CreateTopicRequest) ([]byte, error) <span class="cov8" title="4">{
        buf := new(bytes.Buffer)

        if err := binary.Write(buf, binary.BigEndian, int16(ProtocolVersion)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="4">if err := binary.Write(buf, binary.BigEndian, int16(len(req.Name))); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="4">if _, err := buf.WriteString(req.Name); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="4">if err := binary.Write(buf, binary.BigEndian, req.Partitions); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="4">if err := binary.Write(buf, binary.BigEndian, req.Replicas); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="4">return buf.Bytes(), nil</span>
}

// parseCreateTopicResponse parses create topic response
func (a *Admin) parseCreateTopicResponse(topicName string, data []byte) (*CreateTopicResult, error) <span class="cov4" title="2">{
        buf := bytes.NewReader(data)

        result := &amp;CreateTopicResult{
                Name: topicName,
        }

        var errorCode int16
        if err := binary.Read(buf, binary.BigEndian, &amp;errorCode); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read error code: %v", err)
        }</span>

        <span class="cov4" title="2">if errorCode != 0 </span><span class="cov1" title="1">{
                result.Error = fmt.Errorf("failed to create topic, error code: %d", errorCode)
        }</span>

        <span class="cov4" title="2">return result, nil</span>
}

// TopicInfo topic information
type TopicInfo struct {
        Name       string
        Partitions []PartitionInfo
}

// PartitionInfo partition information
type PartitionInfo struct {
        ID       int32
        Leader   int32   // Not supported yet
        Replicas []int32 // Not supported yet
}

// ListTopics lists all topics (not implemented yet, requires server support)
func (a *Admin) ListTopics() ([]TopicInfo, error) <span class="cov1" title="1">{
        // This feature requires server-side protocol support
        return nil, fmt.Errorf("ListTopics feature not implemented yet, requires server support")
}</span>

// DeleteTopic deletes a topic (not implemented yet, requires server support)
func (a *Admin) DeleteTopic(name string) error <span class="cov1" title="1">{
        // This feature requires server-side protocol support
        return fmt.Errorf("DeleteTopic feature not implemented yet, requires server support")
}</span>

// GetTopicInfo gets topic information (not implemented yet, requires server support)
func (a *Admin) GetTopicInfo(name string) (*TopicInfo, error) <span class="cov1" title="1">{
        // This feature requires server-side protocol support
        return nil, fmt.Errorf("GetTopicInfo feature not implemented yet, requires server support")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package client

import (
        "encoding/binary"
        "fmt"
        "io"
        "net"
        "sync"
        "time"
)

// Client configuration
type Client struct {
        brokerAddr string
        timeout    time.Duration
        mu         sync.Mutex
}

// ClientConfig client configuration
type ClientConfig struct {
        BrokerAddr string
        Timeout    time.Duration
}

// NewClient creates a new client
func NewClient(config ClientConfig) *Client <span class="cov10" title="17">{
        if config.BrokerAddr == "" </span><span class="cov9" title="15">{
                config.BrokerAddr = "localhost:9092"
        }</span>
        <span class="cov10" title="17">if config.Timeout == 0 </span><span class="cov9" title="15">{
                config.Timeout = 5 * time.Second
        }</span>

        <span class="cov10" title="17">return &amp;Client{
                brokerAddr: config.BrokerAddr,
                timeout:    config.Timeout,
        }</span>
}

// connect creates a connection to broker
func (c *Client) connect() (net.Conn, error) <span class="cov7" title="9">{
        conn, err := net.DialTimeout("tcp", c.brokerAddr, c.timeout)
        if err != nil </span><span class="cov7" title="9">{
                return nil, fmt.Errorf("failed to connect to broker: %v", err)
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

// sendRequest sends request and handles response
func (c *Client) sendRequest(requestType int32, requestData []byte) ([]byte, error) <span class="cov7" title="8">{
        c.mu.Lock()
        defer c.mu.Unlock()

        conn, err := c.connect()
        if err != nil </span><span class="cov7" title="8">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        conn.SetDeadline(time.Now().Add(c.timeout))

        if err := binary.Write(conn, binary.BigEndian, requestType); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request type: %v", err)
        }</span>

        <span class="cov0" title="0">if _, err := conn.Write(requestData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request data: %v", err)
        }</span>

        <span class="cov0" title="0">var responseLen int32
        if err := binary.Read(conn, binary.BigEndian, &amp;responseLen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response length: %v", err)
        }</span>

        // Calculate actual data length based on protocol
        <span class="cov0" title="0">actualDataLen := responseLen
        if requestType == FetchRequestType </span><span class="cov0" title="0">{
                // For fetch requests, response length includes the 4-byte length header itself
                actualDataLen = responseLen - 4
                if actualDataLen &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid response length: %d", responseLen)
                }</span>
        }

        // Read response data
        <span class="cov0" title="0">responseData := make([]byte, actualDataLen)
        if _, err := io.ReadFull(conn, responseData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response data: %v", err)
        }</span>

        <span class="cov0" title="0">return responseData, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package client

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

// Consumer message consumer
type Consumer struct {
        client *Client
}

// NewConsumer creates a new consumer
func NewConsumer(client *Client) *Consumer <span class="cov10" title="5">{
        return &amp;Consumer{
                client: client,
        }
}</span>

// FetchRequest fetch request
type FetchRequest struct {
        Topic     string
        Partition int32
        Offset    int64
        MaxBytes  int32
}

// Message message structure
type Message struct {
        Topic     string
        Partition int32
        Offset    int64
        Value     []byte
}

// FetchResult fetch result
type FetchResult struct {
        Topic      string
        Partition  int32
        Messages   []Message
        NextOffset int64
        Error      error
}

// Fetch fetches messages
func (c *Consumer) Fetch(req FetchRequest) (*FetchResult, error) <span class="cov7" title="3">{
        // Set default values
        if req.MaxBytes &lt;= 0 </span><span class="cov1" title="1">{
                req.MaxBytes = 1024 * 1024 // default 1MB
        }</span>

        // Build request data
        <span class="cov7" title="3">requestData, err := c.buildFetchRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build request: %v", err)
        }</span>

        // Send request with fetch-specific protocol handling
        <span class="cov7" title="3">responseData, err := c.client.sendRequest(FetchRequestType, requestData)
        if err != nil </span><span class="cov7" title="3">{
                return nil, fmt.Errorf("failed to send request: %v", err)
        }</span>

        // Parse response
        <span class="cov0" title="0">result, err := c.parseFetchResponse(req.Topic, req.Partition, req.Offset, responseData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %v", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// FetchFrom fetches messages starting from specified offset
func (c *Consumer) FetchFrom(topic string, partition int32, offset int64) (*FetchResult, error) <span class="cov1" title="1">{
        return c.Fetch(FetchRequest{
                Topic:     topic,
                Partition: partition,
                Offset:    offset,
                MaxBytes:  1024 * 1024, // 1MB
        })
}</span>

// buildFetchRequest builds fetch request
func (c *Consumer) buildFetchRequest(req FetchRequest) ([]byte, error) <span class="cov8" title="4">{
        buf := new(bytes.Buffer)

        // 1. Protocol version
        if err := binary.Write(buf, binary.BigEndian, int16(ProtocolVersion)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 2. Topic length and content
        <span class="cov8" title="4">if err := binary.Write(buf, binary.BigEndian, int16(len(req.Topic))); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="4">if _, err := buf.WriteString(req.Topic); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 3. Partition
        <span class="cov8" title="4">if err := binary.Write(buf, binary.BigEndian, req.Partition); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 4. Offset
        <span class="cov8" title="4">if err := binary.Write(buf, binary.BigEndian, req.Offset); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. MaxBytes
        <span class="cov8" title="4">if err := binary.Write(buf, binary.BigEndian, req.MaxBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="4">return buf.Bytes(), nil</span>
}

// parseFetchResponse parses fetch response
func (c *Consumer) parseFetchResponse(topic string, partition int32, requestOffset int64, data []byte) (*FetchResult, error) <span class="cov1" title="1">{
        buf := bytes.NewReader(data)

        result := &amp;FetchResult{
                Topic:     topic,
                Partition: partition,
                Messages:  make([]Message, 0),
        }

        // 1. Read Topic (confirmation)
        var topicLen int16
        if err := binary.Read(buf, binary.BigEndian, &amp;topicLen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read topic length: %v", err)
        }</span>
        <span class="cov1" title="1">topicBytes := make([]byte, topicLen)
        if _, err := io.ReadFull(buf, topicBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read topic: %v", err)
        }</span>

        // 2. Read Partition
        <span class="cov1" title="1">var responsePartition int32
        if err := binary.Read(buf, binary.BigEndian, &amp;responsePartition); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read partition: %v", err)
        }</span>

        // 3. Read ErrorCode
        <span class="cov1" title="1">var errorCode int16
        if err := binary.Read(buf, binary.BigEndian, &amp;errorCode); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read error code: %v", err)
        }</span>

        <span class="cov1" title="1">if errorCode != 0 </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("server error, error code: %d", errorCode)
                return result, nil
        }</span>

        // 4. Read NextOffset
        <span class="cov1" title="1">if err := binary.Read(buf, binary.BigEndian, &amp;result.NextOffset); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read next offset: %v", err)
        }</span>

        // 5. Read message count
        <span class="cov1" title="1">var messageCount int32
        if err := binary.Read(buf, binary.BigEndian, &amp;messageCount); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read message count: %v", err)
        }</span>

        // 6. Read message content
        <span class="cov1" title="1">currentOffset := requestOffset // Start from the requested offset
        for i := int32(0); i &lt; messageCount; i++ </span><span class="cov1" title="1">{
                // Read message length
                var msgLen int32
                if err := binary.Read(buf, binary.BigEndian, &amp;msgLen); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read message %d length: %v", i, err)
                }</span>

                // Validate message length
                <span class="cov1" title="1">if msgLen &lt; 0 || msgLen &gt; 1024*1024 </span><span class="cov0" title="0">{ // Max 1MB per message
                        return nil, fmt.Errorf("invalid message length: %d", msgLen)
                }</span>

                // Read message content
                <span class="cov1" title="1">msgData := make([]byte, msgLen)
                if _, err := io.ReadFull(buf, msgData); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read message %d content: %v", i, err)
                }</span>

                <span class="cov1" title="1">message := Message{
                        Topic:     topic,
                        Partition: partition,
                        Offset:    currentOffset,
                        Value:     msgData,
                }
                result.Messages = append(result.Messages, message)
                currentOffset++</span>
        }

        <span class="cov1" title="1">return result, nil</span>
}

// Subscribe simple consumer subscription (starting from latest position)
func (c *Consumer) Subscribe(topic string, partition int32, handler func(Message) error) error <span class="cov0" title="0">{
        offset := int64(0) // Start from beginning, in actual applications offset should be saved

        for </span><span class="cov0" title="0">{
                result, err := c.FetchFrom(topic, partition, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to fetch messages: %v", err)
                }</span>

                <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %v", result.Error)
                }</span>

                // Process messages
                <span class="cov0" title="0">for _, msg := range result.Messages </span><span class="cov0" title="0">{
                        if err := handler(msg); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to process message: %v", err)
                        }</span>
                        <span class="cov0" title="0">offset = msg.Offset + 1</span>
                }

                // If no new messages, wait for a while
                <span class="cov0" title="0">if len(result.Messages) == 0 </span><span class="cov0" title="0">{
                        // In actual applications, this should implement smarter polling strategy
                        break</span>
                }

                // Update offset to next position
                <span class="cov0" title="0">if result.NextOffset &gt; offset </span><span class="cov0" title="0">{
                        offset = result.NextOffset
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package client

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
        "log"
        "sync"
        "time"
)

// GroupConsumer 消费者组消费者
type GroupConsumer struct {
        client         *Client
        GroupID        string
        ConsumerID     string
        Topics         []string
        SessionTimeout time.Duration

        // 内部状态
        generation int32
        leader     string
        assignment map[string][]int32
        members    []GroupMember

        // 心跳相关
        heartbeatTicker *time.Ticker
        stopHeartbeat   chan struct{}

        // 状态锁
        mu sync.RWMutex
}

// GroupMember 组成员信息
type GroupMember struct {
        ID       string
        ClientID string
}

// GroupConsumerConfig 消费者组配置
type GroupConsumerConfig struct {
        GroupID        string
        ConsumerID     string
        Topics         []string
        SessionTimeout time.Duration
}

// 请求类型常量
const (
        JoinGroupRequestType    = 3
        LeaveGroupRequestType   = 4
        HeartbeatRequestType    = 5
        CommitOffsetRequestType = 6
        FetchOffsetRequestType  = 7
)

// NewGroupConsumer 创建新的消费者组消费者
func NewGroupConsumer(client *Client, config GroupConsumerConfig) *GroupConsumer <span class="cov0" title="0">{
        if config.SessionTimeout == 0 </span><span class="cov0" title="0">{
                config.SessionTimeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;GroupConsumer{
                client:         client,
                GroupID:        config.GroupID,
                ConsumerID:     config.ConsumerID,
                Topics:         config.Topics,
                SessionTimeout: config.SessionTimeout,
                assignment:     make(map[string][]int32),
                stopHeartbeat:  make(chan struct{}),
        }</span>
}

// JoinGroup 加入消费者组
func (gc *GroupConsumer) JoinGroup() error <span class="cov0" title="0">{
        gc.mu.Lock()
        defer gc.mu.Unlock()

        log.Printf("Joining consumer group: %s with consumer ID: %s", gc.GroupID, gc.ConsumerID)

        // 构建请求
        requestData, err := gc.buildJoinGroupRequest()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build join group request: %v", err)
        }</span>

        // 发送请求
        <span class="cov0" title="0">responseData, err := gc.client.sendRequest(JoinGroupRequestType, requestData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send join group request: %v", err)
        }</span>

        // 解析响应
        <span class="cov0" title="0">err = gc.parseJoinGroupResponse(responseData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse join group response: %v", err)
        }</span>

        // 开始心跳
        <span class="cov0" title="0">gc.startHeartbeat()

        log.Printf("Successfully joined group %s, generation: %d, leader: %s",
                gc.GroupID, gc.generation, gc.leader)

        return nil</span>
}

// LeaveGroup 离开消费者组
func (gc *GroupConsumer) LeaveGroup() error <span class="cov0" title="0">{
        gc.mu.Lock()
        defer gc.mu.Unlock()

        log.Printf("Leaving consumer group: %s", gc.GroupID)

        // 停止心跳
        gc.stopHeartbeatInternal()

        // 构建请求
        requestData, err := gc.buildLeaveGroupRequest()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build leave group request: %v", err)
        }</span>

        // 发送请求
        <span class="cov0" title="0">responseData, err := gc.client.sendRequest(LeaveGroupRequestType, requestData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send leave group request: %v", err)
        }</span>

        // 解析响应
        <span class="cov0" title="0">err = gc.parseLeaveGroupResponse(responseData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse leave group response: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully left group %s", gc.GroupID)
        return nil</span>
}

// CommitOffset 提交offset
func (gc *GroupConsumer) CommitOffset(topic string, partition int32, offset int64, metadata string) error <span class="cov0" title="0">{
        log.Printf("Committing offset: group=%s, topic=%s, partition=%d, offset=%d",
                gc.GroupID, topic, partition, offset)

        // 构建请求
        requestData, err := gc.buildCommitOffsetRequest(topic, partition, offset, metadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build commit offset request: %v", err)
        }</span>

        // 发送请求
        <span class="cov0" title="0">responseData, err := gc.client.sendRequest(CommitOffsetRequestType, requestData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send commit offset request: %v", err)
        }</span>

        // 解析响应
        <span class="cov0" title="0">err = gc.parseCommitOffsetResponse(responseData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse commit offset response: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FetchCommittedOffset 获取已提交的offset
func (gc *GroupConsumer) FetchCommittedOffset(topic string, partition int32) (int64, error) <span class="cov0" title="0">{
        // 构建请求
        requestData, err := gc.buildFetchOffsetRequest(topic, partition)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to build fetch offset request: %v", err)
        }</span>

        // 发送请求
        <span class="cov0" title="0">responseData, err := gc.client.sendRequest(FetchOffsetRequestType, requestData)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to send fetch offset request: %v", err)
        }</span>

        // 解析响应
        <span class="cov0" title="0">offset, err := gc.parseFetchOffsetResponse(responseData)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to parse fetch offset response: %v", err)
        }</span>

        <span class="cov0" title="0">return offset, nil</span>
}

// GetAssignment 获取分区分配
func (gc *GroupConsumer) GetAssignment() map[string][]int32 <span class="cov0" title="0">{
        gc.mu.RLock()
        defer gc.mu.RUnlock()

        // 返回副本以避免外部修改
        assignment := make(map[string][]int32)
        for topic, partitions := range gc.assignment </span><span class="cov0" title="0">{
                partitionsCopy := make([]int32, len(partitions))
                copy(partitionsCopy, partitions)
                assignment[topic] = partitionsCopy
        }</span>
        <span class="cov0" title="0">return assignment</span>
}

// 内部方法

func (gc *GroupConsumer) startHeartbeat() <span class="cov0" title="0">{
        gc.heartbeatTicker = time.NewTicker(gc.SessionTimeout / 3) // 心跳间隔为会话超时的1/3

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-gc.heartbeatTicker.C:<span class="cov0" title="0">
                                if err := gc.sendHeartbeat(); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Heartbeat failed: %v", err)
                                }</span>
                        case &lt;-gc.stopHeartbeat:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

func (gc *GroupConsumer) stopHeartbeatInternal() <span class="cov0" title="0">{
        if gc.heartbeatTicker != nil </span><span class="cov0" title="0">{
                gc.heartbeatTicker.Stop()
                close(gc.stopHeartbeat)
                gc.stopHeartbeat = make(chan struct{}) // 重新创建以便后续使用
        }</span>
}

func (gc *GroupConsumer) sendHeartbeat() error <span class="cov0" title="0">{
        // 构建请求
        requestData, err := gc.buildHeartbeatRequest()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build heartbeat request: %v", err)
        }</span>

        // 发送请求
        <span class="cov0" title="0">responseData, err := gc.client.sendRequest(HeartbeatRequestType, requestData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send heartbeat request: %v", err)
        }</span>

        // 解析响应
        <span class="cov0" title="0">return gc.parseHeartbeatResponse(responseData)</span>
}

// 构建请求的方法

func (gc *GroupConsumer) buildJoinGroupRequest() ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // 协议版本
        binary.Write(buf, binary.BigEndian, int16(1))

        // GroupID
        binary.Write(buf, binary.BigEndian, int16(len(gc.GroupID)))
        buf.WriteString(gc.GroupID)

        // ConsumerID
        binary.Write(buf, binary.BigEndian, int16(len(gc.ConsumerID)))
        buf.WriteString(gc.ConsumerID)

        // ClientID
        clientID := "go-queue-client"
        binary.Write(buf, binary.BigEndian, int16(len(clientID)))
        buf.WriteString(clientID)

        // Topics
        binary.Write(buf, binary.BigEndian, int32(len(gc.Topics)))
        for _, topic := range gc.Topics </span><span class="cov0" title="0">{
                binary.Write(buf, binary.BigEndian, int16(len(topic)))
                buf.WriteString(topic)
        }</span>

        // SessionTimeout (毫秒)
        <span class="cov0" title="0">sessionTimeoutMs := int32(gc.SessionTimeout / time.Millisecond)
        binary.Write(buf, binary.BigEndian, sessionTimeoutMs)

        return buf.Bytes(), nil</span>
}

func (gc *GroupConsumer) buildLeaveGroupRequest() ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // 协议版本
        binary.Write(buf, binary.BigEndian, int16(1))

        // GroupID
        binary.Write(buf, binary.BigEndian, int16(len(gc.GroupID)))
        buf.WriteString(gc.GroupID)

        // ConsumerID
        binary.Write(buf, binary.BigEndian, int16(len(gc.ConsumerID)))
        buf.WriteString(gc.ConsumerID)

        return buf.Bytes(), nil
}</span>

func (gc *GroupConsumer) buildHeartbeatRequest() ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // 协议版本
        binary.Write(buf, binary.BigEndian, int16(1))

        // GroupID
        binary.Write(buf, binary.BigEndian, int16(len(gc.GroupID)))
        buf.WriteString(gc.GroupID)

        // ConsumerID
        binary.Write(buf, binary.BigEndian, int16(len(gc.ConsumerID)))
        buf.WriteString(gc.ConsumerID)

        // Generation
        binary.Write(buf, binary.BigEndian, gc.generation)

        return buf.Bytes(), nil
}</span>

func (gc *GroupConsumer) buildCommitOffsetRequest(topic string, partition int32, offset int64, metadata string) ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // 协议版本
        binary.Write(buf, binary.BigEndian, int16(1))

        // GroupID
        binary.Write(buf, binary.BigEndian, int16(len(gc.GroupID)))
        buf.WriteString(gc.GroupID)

        // Topic
        binary.Write(buf, binary.BigEndian, int16(len(topic)))
        buf.WriteString(topic)

        // Partition
        binary.Write(buf, binary.BigEndian, partition)

        // Offset
        binary.Write(buf, binary.BigEndian, offset)

        // Metadata
        binary.Write(buf, binary.BigEndian, int16(len(metadata)))
        buf.WriteString(metadata)

        return buf.Bytes(), nil
}</span>

func (gc *GroupConsumer) buildFetchOffsetRequest(topic string, partition int32) ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // 协议版本
        binary.Write(buf, binary.BigEndian, int16(1))

        // GroupID
        binary.Write(buf, binary.BigEndian, int16(len(gc.GroupID)))
        buf.WriteString(gc.GroupID)

        // Topic
        binary.Write(buf, binary.BigEndian, int16(len(topic)))
        buf.WriteString(topic)

        // Partition
        binary.Write(buf, binary.BigEndian, partition)

        return buf.Bytes(), nil
}</span>

// 解析响应的方法

func (gc *GroupConsumer) parseJoinGroupResponse(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        // ErrorCode
        var errorCode int16
        if err := binary.Read(buf, binary.BigEndian, &amp;errorCode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if errorCode != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("join group failed with error code: %d", errorCode)
        }</span>

        // Generation
        <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;gc.generation); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // GroupID
        <span class="cov0" title="0">var groupIDLen int16
        if err := binary.Read(buf, binary.BigEndian, &amp;groupIDLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">groupIDBytes := make([]byte, groupIDLen)
        if _, err := io.ReadFull(buf, groupIDBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // ConsumerID
        <span class="cov0" title="0">var consumerIDLen int16
        if err := binary.Read(buf, binary.BigEndian, &amp;consumerIDLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">consumerIDBytes := make([]byte, consumerIDLen)
        if _, err := io.ReadFull(buf, consumerIDBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Leader
        <span class="cov0" title="0">var leaderLen int16
        if err := binary.Read(buf, binary.BigEndian, &amp;leaderLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">leaderBytes := make([]byte, leaderLen)
        if _, err := io.ReadFull(buf, leaderBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">gc.leader = string(leaderBytes)

        // Members
        var memberCount int32
        if err := binary.Read(buf, binary.BigEndian, &amp;memberCount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">gc.members = make([]GroupMember, memberCount)
        for i := int32(0); i &lt; memberCount; i++ </span><span class="cov0" title="0">{
                var memberIDLen int16
                if err := binary.Read(buf, binary.BigEndian, &amp;memberIDLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">memberIDBytes := make([]byte, memberIDLen)
                if _, err := io.ReadFull(buf, memberIDBytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var clientIDLen int16
                if err := binary.Read(buf, binary.BigEndian, &amp;clientIDLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">clientIDBytes := make([]byte, clientIDLen)
                if _, err := io.ReadFull(buf, clientIDBytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">gc.members[i] = GroupMember{
                        ID:       string(memberIDBytes),
                        ClientID: string(clientIDBytes),
                }</span>
        }

        // Assignment
        <span class="cov0" title="0">var assignmentCount int32
        if err := binary.Read(buf, binary.BigEndian, &amp;assignmentCount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">gc.assignment = make(map[string][]int32)
        for i := int32(0); i &lt; assignmentCount; i++ </span><span class="cov0" title="0">{
                var topicLen int16
                if err := binary.Read(buf, binary.BigEndian, &amp;topicLen); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">topicBytes := make([]byte, topicLen)
                if _, err := io.ReadFull(buf, topicBytes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">topic := string(topicBytes)

                var partitionCount int32
                if err := binary.Read(buf, binary.BigEndian, &amp;partitionCount); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">partitions := make([]int32, partitionCount)
                for j := int32(0); j &lt; partitionCount; j++ </span><span class="cov0" title="0">{
                        if err := binary.Read(buf, binary.BigEndian, &amp;partitions[j]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">gc.assignment[topic] = partitions</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (gc *GroupConsumer) parseLeaveGroupResponse(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        var errorCode int16
        if err := binary.Read(buf, binary.BigEndian, &amp;errorCode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if errorCode != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("leave group failed with error code: %d", errorCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (gc *GroupConsumer) parseHeartbeatResponse(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        var errorCode int16
        if err := binary.Read(buf, binary.BigEndian, &amp;errorCode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if errorCode != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("heartbeat failed with error code: %d", errorCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (gc *GroupConsumer) parseCommitOffsetResponse(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        var errorCode int16
        if err := binary.Read(buf, binary.BigEndian, &amp;errorCode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if errorCode != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("commit offset failed with error code: %d", errorCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (gc *GroupConsumer) parseFetchOffsetResponse(data []byte) (int64, error) <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        var errorCode int16
        if err := binary.Read(buf, binary.BigEndian, &amp;errorCode); err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">if errorCode != 0 </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("fetch offset failed with error code: %d", errorCode)
        }</span>

        <span class="cov0" title="0">var offset int64
        if err := binary.Read(buf, binary.BigEndian, &amp;offset); err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">return offset, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package client

import (
        "bytes"
        "encoding/binary"
        "fmt"
)

const (
        ProduceRequestType     = 0
        FetchRequestType       = 1
        CreateTopicRequestType = 2

        ProtocolVersion = 1

        CompressionNone = 0
)

// Producer message producer
type Producer struct {
        client *Client
}

// NewProducer creates a new producer
func NewProducer(client *Client) *Producer <span class="cov7" title="4">{
        return &amp;Producer{
                client: client,
        }
}</span>

// ProduceMessage single message structure
type ProduceMessage struct {
        Topic     string
        Partition int32
        Value     []byte
}

// ProduceResult production result
type ProduceResult struct {
        Topic     string
        Partition int32
        Offset    int64
        Error     error
}

// Send sends a single message
func (p *Producer) Send(msg ProduceMessage) (*ProduceResult, error) <span class="cov0" title="0">{
        return p.SendBatch([]ProduceMessage{msg})
}</span>

// SendBatch sends messages in batch
func (p *Producer) SendBatch(messages []ProduceMessage) (*ProduceResult, error) <span class="cov8" title="5">{
        if len(messages) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("message list cannot be empty")
        }</span>

        <span class="cov7" title="4">topic := messages[0].Topic
        partition := messages[0].Partition
        for _, msg := range messages </span><span class="cov10" title="7">{
                if msg.Topic != topic || msg.Partition != partition </span><span class="cov4" title="2">{
                        return nil, fmt.Errorf("batch messages must belong to the same topic and partition")
                }</span>
        }

        <span class="cov4" title="2">requestData, err := p.buildProduceRequest(topic, partition, messages)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build request: %v", err)
        }</span>

        <span class="cov4" title="2">responseData, err := p.client.sendRequest(ProduceRequestType, requestData)
        if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("failed to send request: %v", err)
        }</span>

        <span class="cov0" title="0">result, err := p.parseProduceResponse(topic, partition, responseData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %v", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// buildProduceRequest builds produce request
func (p *Producer) buildProduceRequest(topic string, partition int32, messages []ProduceMessage) ([]byte, error) <span class="cov6" title="3">{
        buf := new(bytes.Buffer)

        if err := binary.Write(buf, binary.BigEndian, int16(ProtocolVersion)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">if err := binary.Write(buf, binary.BigEndian, int16(len(topic))); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="3">if _, err := buf.WriteString(topic); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">if err := binary.Write(buf, binary.BigEndian, partition); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">if err := binary.Write(buf, binary.BigEndian, int8(CompressionNone)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">messagesBuf := new(bytes.Buffer)
        for _, msg := range messages </span><span class="cov8" title="5">{
                if err := binary.Write(messagesBuf, binary.BigEndian, int32(len(msg.Value))); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="5">if _, err := messagesBuf.Write(msg.Value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov6" title="3">if err := binary.Write(buf, binary.BigEndian, int32(messagesBuf.Len())); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">if _, err := buf.Write(messagesBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="3">return buf.Bytes(), nil</span>
}

// parseProduceResponse parses produce response
func (p *Producer) parseProduceResponse(topic string, partition int32, data []byte) (*ProduceResult, error) <span class="cov1" title="1">{
        buf := bytes.NewReader(data)

        var baseOffset int64
        if err := binary.Read(buf, binary.BigEndian, &amp;baseOffset); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read base offset: %v", err)
        }</span>

        <span class="cov1" title="1">var errorCode int16
        if err := binary.Read(buf, binary.BigEndian, &amp;errorCode); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read error code: %v", err)
        }</span>

        <span class="cov1" title="1">result := &amp;ProduceResult{
                Topic:     topic,
                Partition: partition,
                Offset:    baseOffset,
        }

        if errorCode != 0 </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("server error, error code: %d", errorCode)
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "encoding/binary"
        "flag"
        "log"
        "net"
        "os"

        "github.com/issac1998/go-queue/internal/cluster"
        "github.com/issac1998/go-queue/internal/config"
        "github.com/issac1998/go-queue/internal/metadata"
        "github.com/issac1998/go-queue/internal/protocol"
)

const (
        produceRequest      = 0
        fetchRequest        = 1
        createTopicRequest  = 2
        joinGroupRequest    = 3
        leaveGroupRequest   = 4
        heartbeatRequest    = 5
        commitOffsetRequest = 6
        fetchOffsetRequest  = 7
)

var (
        manager        *metadata.Manager
        clusterManager *cluster.Manager
)

func main() <span class="cov0" title="0">{
        var (
                configFile = flag.String("config", "configs/broker.json", "Configuration file path")
        )
        flag.Parse()

        // Load configuration from file
        brokerConfig, err := config.LoadBrokerConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Set log output
        <span class="cov0" title="0">if brokerConfig.Server.LogFile != "" </span><span class="cov0" title="0">{
                file, err := os.OpenFile(brokerConfig.Server.LogFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to open log file %s: %v", brokerConfig.Server.LogFile, err)
                }</span>
                <span class="cov0" title="0">defer file.Close()
                log.SetOutput(file)
                log.Printf("Log output to file: %s", brokerConfig.Server.LogFile)</span>
        }

        <span class="cov0" title="0">log.Printf("Go Queue server starting - port:%s, data directory:%s",
                brokerConfig.Server.Port, brokerConfig.Config.DataDir)

        // Initialize Manager with loaded configuration
        manager, err = metadata.NewManager(brokerConfig.Config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize Manager: %v", err)
        }</span>

        <span class="cov0" title="0">if err := manager.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start Manager: %v", err)
        }</span>

        // Initialize cluster if enabled
        <span class="cov0" title="0">if brokerConfig.Cluster.Enabled </span><span class="cov0" title="0">{
                log.Printf("Cluster mode enabled - NodeID: %d, RaftAddress: %s",
                        brokerConfig.Cluster.NodeID, brokerConfig.Cluster.RaftAddress)

                clusterManager, err = cluster.NewManager(brokerConfig.Cluster.NodeID, &amp;brokerConfig.Cluster, manager)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to initialize cluster manager: %v", err)
                }</span>

                <span class="cov0" title="0">log.Printf("Cluster manager initialized successfully")</span>
        }

        // Ensure data directory exists
        <span class="cov0" title="0">os.MkdirAll(brokerConfig.Config.DataDir, 0755)

        // Create raft data directory if cluster is enabled
        if brokerConfig.Cluster.Enabled </span><span class="cov0" title="0">{
                os.MkdirAll(brokerConfig.Cluster.DataDir, 0755)
        }</span>

        <span class="cov0" title="0">log.Printf("Go Queue server started on :%s", brokerConfig.Server.Port)

        ln, err := net.Listen("tcp", ":"+brokerConfig.Server.Port)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen on port: %v", err)
        }</span>
        <span class="cov0" title="0">defer ln.Close()

        for </span><span class="cov0" title="0">{
                conn, err := ln.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to accept connection: %v", err)
                        continue</span>
                }
                <span class="cov0" title="0">go handleConnection(conn)</span>
        }
}

func handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer conn.Close()

        for </span><span class="cov0" title="0">{
                // Read request type
                var reqType int32
                if err := binary.Read(conn, binary.BigEndian, &amp;reqType); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">switch reqType </span>{
                case produceRequest:<span class="cov0" title="0">
                        protocol.HandleProduceRequest(conn, manager, clusterManager)</span>
                case fetchRequest:<span class="cov0" title="0">
                        protocol.HandleFetchRequest(conn, manager)</span>
                case createTopicRequest:<span class="cov0" title="0">
                        protocol.HandleCreateTopicRequest(conn, manager)</span>
                case joinGroupRequest:<span class="cov0" title="0">
                        protocol.HandleJoinGroupRequest(conn, manager)</span>
                case leaveGroupRequest:<span class="cov0" title="0">
                        protocol.HandleLeaveGroupRequest(conn, manager)</span>
                case heartbeatRequest:<span class="cov0" title="0">
                        protocol.HandleHeartbeatRequest(conn, manager)</span>
                case commitOffsetRequest:<span class="cov0" title="0">
                        protocol.HandleCommitOffsetRequest(conn, manager)</span>
                case fetchOffsetRequest:<span class="cov0" title="0">
                        protocol.HandleFetchOffsetRequest(conn, manager)</span>
                default:<span class="cov0" title="0">
                        log.Printf("Unknown request type: %d", reqType)
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"

        "github.com/issac1998/go-queue/client"
        "github.com/issac1998/go-queue/internal/config"
)

func main() <span class="cov0" title="0">{
        var (
                configFile = flag.String("config", "configs/client.json", "Configuration file path")
                command    = flag.String("cmd", "", "Command: create-topic, produce, consume (overrides config)")
                topic      = flag.String("topic", "", "Topic name (overrides config)")
                partition  = flag.Int("partition", -1, "Partition ID (overrides config)")
                message    = flag.String("message", "", "Message to send (overrides config)")
                offset     = flag.Int64("offset", -1, "Consume start offset (overrides config)")
                count      = flag.Int("count", -1, "Message count (overrides config)")
                broker     = flag.String("broker", "", "Broker address (overrides config)")
                logFile    = flag.String("log", "", "Log file path (overrides config)")
        )
        flag.Parse()

        // Load configuration from file
        clientConfig, err := config.LoadClientConfig(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Override config with command line arguments if provided
        <span class="cov0" title="0">if *broker != "" </span><span class="cov0" title="0">{
                clientConfig.Broker = *broker
        }</span>
        <span class="cov0" title="0">if *logFile != "" </span><span class="cov0" title="0">{
                clientConfig.LogFile = *logFile
        }</span>
        <span class="cov0" title="0">if *command != "" </span><span class="cov0" title="0">{
                clientConfig.Command.Type = *command
        }</span>
        <span class="cov0" title="0">if *topic != "" </span><span class="cov0" title="0">{
                clientConfig.Command.Topic = *topic
        }</span>
        <span class="cov0" title="0">if *partition &gt;= 0 </span><span class="cov0" title="0">{
                clientConfig.Command.Partition = *partition
        }</span>
        <span class="cov0" title="0">if *message != "" </span><span class="cov0" title="0">{
                clientConfig.Command.Message = *message
        }</span>
        <span class="cov0" title="0">if *offset &gt;= 0 </span><span class="cov0" title="0">{
                clientConfig.Command.Offset = *offset
        }</span>
        <span class="cov0" title="0">if *count &gt;= 0 </span><span class="cov0" title="0">{
                clientConfig.Command.Count = *count
        }</span>

        // Set log output
        <span class="cov0" title="0">if clientConfig.LogFile != "" </span><span class="cov0" title="0">{
                file, err := os.OpenFile(clientConfig.LogFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to open log file %s: %v", clientConfig.LogFile, err)
                }</span>
                <span class="cov0" title="0">defer file.Close()
                log.SetOutput(file)
                log.Printf("Client log output to file: %s", clientConfig.LogFile)</span>
        }

        <span class="cov0" title="0">if clientConfig.Command.Type == "" </span><span class="cov0" title="0">{
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Printf("Go Queue client starting - Broker: %s, Command: %s",
                clientConfig.Broker, clientConfig.Command.Type)

        // Parse timeout
        timeout, err := clientConfig.GetTimeoutDuration()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid timeout configuration: %v", err)
        }</span>

        // Create client
        <span class="cov0" title="0">c := client.NewClient(client.ClientConfig{
                BrokerAddr: clientConfig.Broker,
                Timeout:    timeout,
        })

        switch clientConfig.Command.Type </span>{
        case "create-topic":<span class="cov0" title="0">
                createTopic(c, clientConfig.Command.Topic)</span>
        case "produce":<span class="cov0" title="0">
                produce(c, clientConfig.Command.Topic, int32(clientConfig.Command.Partition),
                        clientConfig.Command.Message, clientConfig.Command.Count)</span>
        case "consume":<span class="cov0" title="0">
                consume(c, clientConfig.Command.Topic, int32(clientConfig.Command.Partition),
                        clientConfig.Command.Offset)</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown command: %s\n", clientConfig.Command.Type)
                printUsage()
                os.Exit(1)</span>
        }
}

func printUsage() <span class="cov0" title="0">{
        fmt.Println("Go Queue Client Tool")
        fmt.Println()
        fmt.Println("Usage:")
        fmt.Println("  With config file: go run main.go -config=configs/client.json")
        fmt.Println("  Override config: go run main.go -config=configs/client.json -cmd=produce -topic=my-topic")
        fmt.Println("  Command line only: go run main.go -cmd=create-topic -topic=my-topic -broker=localhost:9092")
        fmt.Println()
        fmt.Println("Commands:")
        fmt.Println("  create-topic: Create a new topic")
        fmt.Println("  produce: Send messages to a topic")
        fmt.Println("  consume: Consume messages from a topic")
        fmt.Println()
        fmt.Println("Parameters:")
        flag.PrintDefaults()
}</span>

func createTopic(c *client.Client, topicName string) <span class="cov0" title="0">{
        if topicName == "" </span><span class="cov0" title="0">{
                log.Fatal("Please specify topic name")
        }</span>

        <span class="cov0" title="0">log.Printf("Starting to create topic: %s", topicName)
        admin := client.NewAdmin(c)
        result, err := admin.CreateTopic(client.CreateTopicRequest{
                Name:       topicName,
                Partitions: 1,
                Replicas:   1,
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create topic: %v", err)
        }</span>

        <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create topic: %v", result.Error)
        }</span>

        <span class="cov0" title="0">log.Printf("Topic '%s' created successfully", result.Name)
        fmt.Printf("Topic '%s' created successfully!\n", result.Name)</span>
}

func produce(c *client.Client, topicName string, partition int32, message string, count int) <span class="cov0" title="0">{
        if topicName == "" </span><span class="cov0" title="0">{
                log.Fatal("Please specify topic name")
        }</span>
        <span class="cov0" title="0">if message == "" </span><span class="cov0" title="0">{
                log.Fatal("Please specify message to send")
        }</span>

        <span class="cov0" title="0">log.Printf("Starting to send messages to topic: %s, partition: %d, count: %d", topicName, partition, count)
        producer := client.NewProducer(c)

        if count == 1 </span><span class="cov0" title="0">{
                msg := client.ProduceMessage{
                        Topic:     topicName,
                        Partition: partition,
                        Value:     []byte(message),
                }

                log.Printf("Sending single message: %s", message)
                result, err := producer.Send(msg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to send message: %v", err)
                }</span>

                <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to send message: %v", result.Error)
                }</span>

                <span class="cov0" title="0">log.Printf("Message sent successfully! Topic: %s, Partition: %d, Offset: %d", result.Topic, result.Partition, result.Offset)
                fmt.Printf("Message sent successfully! Topic: %s, Partition: %d, Offset: %d\n",
                        result.Topic, result.Partition, result.Offset)</span>
        } else<span class="cov0" title="0"> {
                messages := make([]client.ProduceMessage, count)
                for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                        messages[i] = client.ProduceMessage{
                                Topic:     topicName,
                                Partition: partition,
                                Value:     []byte(fmt.Sprintf("%s-%d", message, i+1)),
                        }
                }</span>

                <span class="cov0" title="0">log.Printf("Sending batch of %d messages", count)
                result, err := producer.SendBatch(messages)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to send batch messages: %v", err)
                }</span>

                <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to send batch messages: %v", result.Error)
                }</span>

                <span class="cov0" title="0">log.Printf("Batch messages sent successfully! Topic: %s, Partition: %d, Start Offset: %d, Count: %d", result.Topic, result.Partition, result.Offset, count)
                fmt.Printf("Batch messages sent successfully! Topic: %s, Partition: %d, Start Offset: %d, Count: %d\n",
                        result.Topic, result.Partition, result.Offset, count)</span>
        }
}

func consume(c *client.Client, topicName string, partition int32, offset int64) <span class="cov0" title="0">{
        if topicName == "" </span><span class="cov0" title="0">{
                log.Fatal("Please specify topic name")
        }</span>

        <span class="cov0" title="0">log.Printf("Starting to consume messages - Topic: %s, Partition: %d, Offset: %d", topicName, partition, offset)
        consumer := client.NewConsumer(c)

        fmt.Printf("Starting to consume messages from Topic: %s, Partition: %d, Offset: %d...\n",
                topicName, partition, offset)

        result, err := consumer.FetchFrom(topicName, partition, offset)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to fetch messages: %v", err)
        }</span>

        <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to fetch messages: %v", result.Error)
        }</span>

        <span class="cov0" title="0">if len(result.Messages) == 0 </span><span class="cov0" title="0">{
                log.Printf("No messages found")
                fmt.Println("No messages found")
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully fetched %d messages", len(result.Messages))
        fmt.Printf("Successfully fetched %d messages:\n", len(result.Messages))
        fmt.Println(strings.Repeat("-", 60))

        for i, msg := range result.Messages </span><span class="cov0" title="0">{
                log.Printf("Message %d: Offset=%d, Content=%s, Length=%d bytes", i+1, msg.Offset, string(msg.Value), len(msg.Value))
                fmt.Printf("Message %d:\n", i+1)
                fmt.Printf("  Offset: %d\n", msg.Offset)
                fmt.Printf("  Content: %s\n", string(msg.Value))
                fmt.Printf("  Length: %d bytes\n", len(msg.Value))
                if i &lt; len(result.Messages)-1 </span><span class="cov0" title="0">{
                        fmt.Println()
                }</span>
        }

        <span class="cov0" title="0">fmt.Println(strings.Repeat("-", 60))
        fmt.Printf("Next Offset: %d\n", result.NextOffset)
        log.Printf("Consumption completed, next Offset: %d", result.NextOffset)</span>
}

func parseTopicPartition(topicPartition string) (string, int32, error) <span class="cov0" title="0">{
        parts := strings.Split(topicPartition, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("format error, should be topic:partition")
        }</span>

        <span class="cov0" title="0">topic := parts[0]
        partition, err := strconv.ParseInt(parts[1], 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to parse partition ID: %v", err)
        }</span>

        <span class="cov0" title="0">return topic, int32(partition), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/issac1998/go-queue/client"
)

func main() <span class="cov0" title="0">{
        fmt.Println("🔧 Go Queue 压缩和去重功能演示")
        fmt.Println(strings.Repeat("=", 60))

        c := client.NewClient(client.ClientConfig{
                BrokerAddr: "localhost:9092",
                Timeout:    10 * time.Second,
        })

        testTopicName := "compression-dedup-demo"

        // 1. 创建主题
        fmt.Println("\n📝 1. 创建演示主题")
        admin := client.NewAdmin(c)
        result, err := admin.CreateTopic(client.CreateTopicRequest{
                Name:       testTopicName,
                Partitions: 1,
                Replicas:   1,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("❌ 创建主题失败: %v", err)
        }</span>
        <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️ 主题可能已存在: %v\n", result.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ 主题 '%s' 创建成功\n", result.Name)
        }</span>

        <span class="cov0" title="0">time.Sleep(1 * time.Second)
        producer := client.NewProducer(c)
        consumer := client.NewConsumer(c)

        // 2. 测试压缩功能
        fmt.Println("\n🗜️ 2. 测试消息压缩功能")

        // 创建一些重复的较大消息来测试压缩
        largeMessage := strings.Repeat("这是一条很长的测试消息，用来验证压缩功能。", 50)

        testMessages := []string{
                "短消息1",
                "短消息2",
                largeMessage,
                largeMessage + " - 变体1",
                largeMessage + " - 变体2",
        }

        fmt.Printf("📊 发送 %d 条测试消息（包含大消息）:\n", len(testMessages))

        var sentOffsets []int64
        for i, content := range testMessages </span><span class="cov0" title="0">{
                msg := client.ProduceMessage{
                        Topic:     testTopicName,
                        Partition: 0,
                        Value:     []byte(content),
                }

                sendResult, err := producer.Send(msg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("❌ 发送消息%d失败: %v", i+1, err)
                        continue</span>
                }
                <span class="cov0" title="0">if sendResult.Error != nil </span><span class="cov0" title="0">{
                        log.Printf("❌ 发送消息%d服务端错误: %v", i+1, sendResult.Error)
                        continue</span>
                }

                <span class="cov0" title="0">sentOffsets = append(sentOffsets, sendResult.Offset)
                fmt.Printf("✅ 消息%d发送成功 - Offset: %d, 大小: %d字节\n",
                        i+1, sendResult.Offset, len(content))</span>
        }

        // 3. 测试去重功能
        <span class="cov0" title="0">fmt.Println("\n🔄 3. 测试消息去重功能")

        // 发送重复消息
        duplicateMsg := client.ProduceMessage{
                Topic:     testTopicName,
                Partition: 0,
                Value:     []byte("这是一条重复消息"),
        }

        fmt.Println("发送原始消息...")
        result1, err := producer.Send(duplicateMsg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("❌ 发送原始消息失败: %v", err)
        }</span> else<span class="cov0" title="0"> if result1.Error != nil </span><span class="cov0" title="0">{
                log.Printf("❌ 发送原始消息服务端错误: %v", result1.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ 原始消息发送成功 - Offset: %d\n", result1.Offset)
        }</span>

        <span class="cov0" title="0">fmt.Println("发送相同内容消息（应该被去重）...")
        result2, err := producer.Send(duplicateMsg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("❌ 发送重复消息失败: %v", err)
        }</span> else<span class="cov0" title="0"> if result2.Error != nil </span><span class="cov0" title="0">{
                log.Printf("❌ 发送重复消息服务端错误: %v", result2.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ 重复消息处理结果 - Offset: %d\n", result2.Offset)
                if result1.Offset == result2.Offset </span><span class="cov0" title="0">{
                        fmt.Println("🎉 去重功能正常工作！返回了相同的offset")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("⚠️ 去重功能可能未启用或配置不正确")
                }</span>
        }

        // 4. 测试批量发送
        <span class="cov0" title="0">fmt.Println("\n📦 4. 测试批量发送")

        batchMessages := []client.ProduceMessage{
                {Topic: testTopicName, Partition: 0, Value: []byte("批量消息1")},
                {Topic: testTopicName, Partition: 0, Value: []byte("批量消息2")},
                {Topic: testTopicName, Partition: 0, Value: []byte(largeMessage)}, // 大消息测试压缩
        }

        batchResult, err := producer.SendBatch(batchMessages)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("❌ 批量发送失败: %v", err)
        }</span> else<span class="cov0" title="0"> if batchResult.Error != nil </span><span class="cov0" title="0">{
                log.Printf("❌ 批量发送服务端错误: %v", batchResult.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ 批量发送成功 - 起始Offset: %d\n", batchResult.Offset)
        }</span>

        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // 5. 读取和验证消息
        fmt.Println("\n📥 5. 读取并验证消息")

        fetchResult, err := consumer.FetchFrom(testTopicName, 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("❌ 读取失败: %v", err)
        }</span> else<span class="cov0" title="0"> if fetchResult.Error != nil </span><span class="cov0" title="0">{
                log.Printf("❌ 读取服务端错误: %v", fetchResult.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✅ 成功读取到 %d 条消息\n", len(fetchResult.Messages))

                fmt.Println("\n📋 消息内容验证:")
                for i, msg := range fetchResult.Messages </span><span class="cov0" title="0">{
                        content := string(msg.Value)
                        contentPreview := content
                        if len(content) &gt; 100 </span><span class="cov0" title="0">{
                                contentPreview = content[:100] + "..."
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("  消息%d (Offset: %d): %s\n", i+1, msg.Offset, contentPreview)

                        // 验证大消息是否正确解压
                        if strings.Contains(content, "这是一条很长的测试消息") </span><span class="cov0" title="0">{
                                fmt.Printf("    📏 大消息长度: %d 字节\n", len(content))
                                if len(content) == len(largeMessage) || len(content) == len(largeMessage+" - 变体1") || len(content) == len(largeMessage+" - 变体2") </span><span class="cov0" title="0">{
                                        fmt.Printf("    ✅ 压缩/解压缩验证通过\n")
                                }</span>
                        }
                }
        }

        // 6. 性能和统计信息
        <span class="cov0" title="0">fmt.Println("\n📊 6. 功能总结")
        fmt.Println("✅ 主题创建: 正常")
        fmt.Printf("✅ 消息发送: 正常 (%d条)\n", len(sentOffsets))
        fmt.Printf("✅ 压缩功能: %s\n", func() string </span><span class="cov0" title="0">{
                if len(largeMessage) &gt; 100 </span><span class="cov0" title="0">{
                        return "已测试大消息压缩"
                }</span>
                <span class="cov0" title="0">return "待测试"</span>
        }())
        <span class="cov0" title="0">fmt.Printf("✅ 去重功能: %s\n", func() string </span><span class="cov0" title="0">{
                if result1 != nil &amp;&amp; result2 != nil &amp;&amp; result1.Offset == result2.Offset </span><span class="cov0" title="0">{
                        return "正常工作"
                }</span>
                <span class="cov0" title="0">return "需要服务端启用"</span>
        }())
        <span class="cov0" title="0">fmt.Printf("✅ 消息读取: %s\n", func() string </span><span class="cov0" title="0">{
                if fetchResult != nil &amp;&amp; len(fetchResult.Messages) &gt; 0 </span><span class="cov0" title="0">{
                        return "正常"
                }</span>
                <span class="cov0" title="0">return "需要调试"</span>
        }())

        <span class="cov0" title="0">fmt.Println("\n💡 功能特性:")
        fmt.Println("  🗜️ 支持多种压缩算法 (Gzip, Zlib, Snappy, Zstd)")
        fmt.Println("  🔄 基于SHA256哈希的消息去重")
        fmt.Println("  ⚡ 自动压缩阈值控制")
        fmt.Println("  📈 压缩比率统计")
        fmt.Println("  🎯 透明的压缩/解压过程")</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/issac1998/go-queue/client"
)

func main() <span class="cov0" title="0">{
        fmt.Println("=== Go Queue Consumer Groups Demo ===")

        // 创建客户端
        c := client.NewClient(client.ClientConfig{
                BrokerAddr: "localhost:9092",
                Timeout:    5 * time.Second,
        })

        // 1. 创建测试topic
        fmt.Println("\n1. Creating test topic...")
        admin := client.NewAdmin(c)
        createResult, err := admin.CreateTopic(client.CreateTopicRequest{
                Name:       "consumer-group-topic",
                Partitions: 4, // 创建4个分区用于演示
                Replicas:   1,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create topic: %v", err)
        }</span> else<span class="cov0" title="0"> if createResult.Error != nil </span><span class="cov0" title="0">{
                log.Printf("Topic creation error: %v", createResult.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✓ Topic '%s' created successfully with 4 partitions!\n", createResult.Name)
        }</span>

        // 2. 发送一些测试消息
        <span class="cov0" title="0">fmt.Println("\n2. Producing test messages...")
        producer := client.NewProducer(c)

        // 发送20条消息到不同分区
        for i := 0; i &lt; 20; i++ </span><span class="cov0" title="0">{
                partition := int32(i % 4) // 轮询分配到4个分区
                message := fmt.Sprintf("Message %d for consumer groups", i+1)

                result, err := producer.Send(client.ProduceMessage{
                        Topic:     "consumer-group-topic",
                        Partition: partition,
                        Value:     []byte(message),
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send message %d: %v", i+1, err)
                        continue</span>
                }
                <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                        log.Printf("Message %d send error: %v", i+1, result.Error)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("  ✓ Sent message %d to partition %d (offset: %d)\n", i+1, partition, result.Offset)</span>
        }

        // 等待消息持久化
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        // 3. 创建消费者组
        fmt.Println("\n3. Creating consumer group with multiple consumers...")

        groupID := "demo-consumer-group"
        topics := []string{"consumer-group-topic"}

        // 创建3个消费者
        var wg sync.WaitGroup
        consumers := make([]*client.GroupConsumer, 3)

        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                consumerID := fmt.Sprintf("consumer-%d", i+1)

                // 创建Group Consumer
                consumers[i] = client.NewGroupConsumer(c, client.GroupConsumerConfig{
                        GroupID:        groupID,
                        ConsumerID:     consumerID,
                        Topics:         topics,
                        SessionTimeout: 30 * time.Second,
                })

                // 加入消费者组
                fmt.Printf("  Consumer %s joining group...\n", consumerID)
                if err := consumers[i].JoinGroup(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Consumer %s failed to join group: %v", consumerID, err)
                        continue</span>
                }

                // 查看分区分配
                <span class="cov0" title="0">assignment := consumers[i].GetAssignment()
                fmt.Printf("  ✓ Consumer %s joined! Assignment: %v\n", consumerID, assignment)</span>
        }

        // 等待一下让分区分配稳定
        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // 4. 每个消费者开始消费消息
        fmt.Println("\n4. Starting message consumption...")

        // 用于统计消费的消息
        consumedMessages := make(map[string][]string) // consumerID -&gt; messages
        var mu sync.Mutex

        for i, consumer := range consumers </span><span class="cov0" title="0">{
                wg.Add(1)
                consumerID := fmt.Sprintf("consumer-%d", i+1)

                go func(gc *client.GroupConsumer, cid string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // 消息处理函数
                        messageHandler := func(msg client.Message) error </span><span class="cov0" title="0">{
                                mu.Lock()
                                if consumedMessages[cid] == nil </span><span class="cov0" title="0">{
                                        consumedMessages[cid] = make([]string, 0)
                                }</span>
                                <span class="cov0" title="0">consumedMessages[cid] = append(consumedMessages[cid], string(msg.Value))
                                mu.Unlock()

                                fmt.Printf("  [%s] Consumed: %s (Topic: %s, Partition: %d, Offset: %d)\n",
                                        cid, string(msg.Value), msg.Topic, msg.Partition, msg.Offset)
                                return nil</span>
                        }

                        // 开始订阅消费（这是阻塞的，在实际应用中可能需要更复杂的控制）
                        <span class="cov0" title="0">fmt.Printf("  %s starting subscription...\n", cid)

                        // 由于Subscribe是阻塞的，我们需要用goroutine控制消费时间
                        done := make(chan struct{})
                        go func() </span><span class="cov0" title="0">{
                                time.Sleep(10 * time.Second) // 消费10秒
                                close(done)
                        }</span>()

                        // 这里我们模拟一个简化的消费循环
                        <span class="cov0" title="0">assignment := gc.GetAssignment()
                        regularConsumer := client.NewConsumer(c)

                        for topic, partitions := range assignment </span><span class="cov0" title="0">{
                                for _, partition := range partitions </span><span class="cov0" title="0">{
                                        go func(t string, p int32) </span><span class="cov0" title="0">{
                                                // 获取已提交的offset
                                                startOffset, err := gc.FetchCommittedOffset(t, p)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        startOffset = 0 // 如果没有提交的offset，从头开始
                                                }</span>

                                                <span class="cov0" title="0">offset := startOffset
                                                for </span><span class="cov0" title="0">{
                                                        select </span>{
                                                        case &lt;-done:<span class="cov0" title="0">
                                                                return</span>
                                                        default:<span class="cov0" title="0">
                                                                // 拉取消息
                                                                result, err := regularConsumer.FetchFrom(t, p, offset)
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        log.Printf("Error fetching from %s:%d: %v", t, p, err)
                                                                        time.Sleep(100 * time.Millisecond)
                                                                        continue</span>
                                                                }

                                                                <span class="cov0" title="0">if result.Error != nil </span><span class="cov0" title="0">{
                                                                        log.Printf("Server error for %s:%d: %v", t, p, result.Error)
                                                                        time.Sleep(100 * time.Millisecond)
                                                                        continue</span>
                                                                }

                                                                // 处理消息
                                                                <span class="cov0" title="0">for _, msg := range result.Messages </span><span class="cov0" title="0">{
                                                                        messageHandler(msg)
                                                                        offset = msg.Offset + 1

                                                                        // 提交offset
                                                                        gc.CommitOffset(t, p, offset, "")
                                                                }</span>

                                                                // 如果没有消息，稍等
                                                                <span class="cov0" title="0">if len(result.Messages) == 0 </span><span class="cov0" title="0">{
                                                                        time.Sleep(100 * time.Millisecond)
                                                                }</span>
                                                        }
                                                }
                                        }(topic, partition)
                                }
                        }

                        // 等待消费完成
                        <span class="cov0" title="0">&lt;-done</span>
                }(consumer, consumerID)
        }

        // 5. 等待消费一段时间
        <span class="cov0" title="0">fmt.Println("\n  Consuming messages for 10 seconds...")
        wg.Wait()

        // 6. 显示消费统计
        fmt.Println("\n5. Consumption statistics:")
        totalConsumed := 0
        for consumerID, messages := range consumedMessages </span><span class="cov0" title="0">{
                fmt.Printf("  %s consumed %d messages\n", consumerID, len(messages))
                totalConsumed += len(messages)
        }</span>
        <span class="cov0" title="0">fmt.Printf("  Total messages consumed: %d\n", totalConsumed)

        // 7. 模拟一个消费者离开
        fmt.Println("\n6. Simulating consumer leave and rebalance...")
        if len(consumers) &gt; 0 </span><span class="cov0" title="0">{
                leavingConsumer := consumers[0]
                fmt.Printf("  Consumer consumer-1 leaving group...\n")

                if err := leavingConsumer.LeaveGroup(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to leave group: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  ✓ Consumer consumer-1 left group successfully\n")
                }</span>

                // 等待其他消费者重新平衡
                <span class="cov0" title="0">time.Sleep(2 * time.Second)

                // 显示剩余消费者的新分配
                for i := 1; i &lt; len(consumers); i++ </span><span class="cov0" title="0">{
                        consumerID := fmt.Sprintf("consumer-%d", i+1)
                        assignment := consumers[i].GetAssignment()
                        fmt.Printf("  %s new assignment after rebalance: %v\n", consumerID, assignment)
                }</span>
        }

        // 8. 清理剩余消费者
        <span class="cov0" title="0">fmt.Println("\n7. Cleaning up remaining consumers...")
        for i := 1; i &lt; len(consumers); i++ </span><span class="cov0" title="0">{
                consumerID := fmt.Sprintf("consumer-%d", i+1)
                fmt.Printf("  %s leaving group...\n", consumerID)

                if err := consumers[i].LeaveGroup(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Consumer %s failed to leave group: %v", consumerID, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  ✓ %s left group successfully\n", consumerID)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("\n=== Consumer Groups Demo Completed! ===")
        fmt.Println("\n✅ Demonstrated features:")
        fmt.Println("  - Consumer group creation and joining")
        fmt.Println("  - Automatic partition assignment (round-robin)")
        fmt.Println("  - Cooperative message consumption")
        fmt.Println("  - Offset tracking and committing")
        fmt.Println("  - Consumer heartbeat mechanism")
        fmt.Println("  - Dynamic rebalancing when consumers leave")
        fmt.Println("  - Graceful consumer group cleanup")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "fmt"
        "log"
        "time"

        "github.com/issac1998/go-queue/client"
)

func main() <span class="cov0" title="0">{
        // Create client
        c := client.NewClient(client.ClientConfig{
                BrokerAddr: "localhost:9092",
                Timeout:    5 * time.Second,
        })

        fmt.Println("=== Go Queue Consumer Protocol Fix Test ===")

        // 1. Create topic for testing
        fmt.Println("\n1. Creating test topic...")
        admin := client.NewAdmin(c)
        createResult, err := admin.CreateTopic(client.CreateTopicRequest{
                Name:       "consume-test-topic",
                Partitions: 1,
                Replicas:   1,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create topic: %v", err)
        }</span> else<span class="cov0" title="0"> if createResult.Error != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create topic: %v", createResult.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✓ Topic '%s' created successfully!\n", createResult.Name)
        }</span>

        <span class="cov0" title="0">producer := client.NewProducer(c)
        consumer := client.NewConsumer(c)

        // 2. Test Single Message Production and Consumption
        fmt.Println("\n2. Testing SINGLE message consumption...")

        singleMessages := []string{
                "Single message test 1",
                "Single message test 2",
                "Single message test 3",
        }

        var singleOffsets []int64

        // Send single messages one by one
        for i, msgText := range singleMessages </span><span class="cov0" title="0">{
                msg := client.ProduceMessage{
                        Topic:     "consume-test-topic",
                        Partition: 0,
                        Value:     []byte(msgText),
                }

                fmt.Printf("  Sending: %s\n", msgText)
                result, err := producer.Send(msg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send single message %d: %v", i+1, err)
                        return
                }</span> else<span class="cov0" title="0"> if result.Error != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send single message %d: %v", i+1, result.Error)
                        return
                }</span>

                <span class="cov0" title="0">singleOffsets = append(singleOffsets, result.Offset)
                fmt.Printf("  ✓ Sent at offset: %d\n", result.Offset)

                // Small delay to ensure ordering
                time.Sleep(10 * time.Millisecond)</span>
        }

        // Test consuming each single message
        <span class="cov0" title="0">fmt.Println("\n  Testing consumption of single messages:")
        for i, offset := range singleOffsets </span><span class="cov0" title="0">{
                fetchResult, err := consumer.FetchFrom("consume-test-topic", 0, offset)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to fetch single message at offset %d: %v", offset, err)
                        continue</span>
                } else<span class="cov0" title="0"> if fetchResult.Error != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to fetch single message at offset %d: %v", offset, fetchResult.Error)
                        continue</span>
                }

                <span class="cov0" title="0">if len(fetchResult.Messages) &gt; 0 </span><span class="cov0" title="0">{
                        msg := fetchResult.Messages[0]
                        fmt.Printf("  ✓ Consumed message %d: %s (Offset: %d)\n", i+1, string(msg.Value), msg.Offset)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  ✗ No message found at offset %d\n", offset)
                }</span>
        }

        // 3. Test Batch Message Production and Consumption
        <span class="cov0" title="0">fmt.Println("\n3. Testing BATCH message consumption...")

        batchMessages := []client.ProduceMessage{
                {Topic: "consume-test-topic", Partition: 0, Value: []byte("Batch message 1")},
                {Topic: "consume-test-topic", Partition: 0, Value: []byte("Batch message 2")},
                {Topic: "consume-test-topic", Partition: 0, Value: []byte("Batch message 3")},
                {Topic: "consume-test-topic", Partition: 0, Value: []byte("Batch message 4")},
                {Topic: "consume-test-topic", Partition: 0, Value: []byte("Batch message 5")},
                {Topic: "consume-test-topic", Partition: 0, Value: []byte("Batch message 6")},
                {Topic: "consume-test-topic", Partition: 0, Value: []byte("Batch message 7")},
        }

        fmt.Printf("  Sending batch of %d messages...\n", len(batchMessages))
        for i, msg := range batchMessages </span><span class="cov0" title="0">{
                fmt.Printf("    [%d]: %s\n", i+1, string(msg.Value))
        }</span>

        <span class="cov0" title="0">batchResult, err := producer.SendBatch(batchMessages)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send batch messages: %v", err)
                return
        }</span> else<span class="cov0" title="0"> if batchResult.Error != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send batch messages: %v", batchResult.Error)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("  ✓ Batch sent successfully! Start offset: %d\n", batchResult.Offset)

        // Wait for persistence
        time.Sleep(50 * time.Millisecond)

        // Test consuming the entire batch
        fmt.Println("\n  Testing consumption of batch messages:")
        batchFetchResult, err := consumer.FetchFrom("consume-test-topic", 0, batchResult.Offset)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to fetch batch messages: %v", err)
        }</span> else<span class="cov0" title="0"> if batchFetchResult.Error != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to fetch batch messages: %v", batchFetchResult.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  ✓ Successfully fetched %d messages from batch:\n", len(batchFetchResult.Messages))
                for i, msg := range batchFetchResult.Messages </span><span class="cov0" title="0">{
                        fmt.Printf("    [%d]: %s (Offset: %d)\n", i+1, string(msg.Value), msg.Offset)
                }</span>
                <span class="cov0" title="0">fmt.Printf("  Next Offset: %d\n", batchFetchResult.NextOffset)</span>
        }

        // 4. Test consuming all messages from beginning
        <span class="cov0" title="0">fmt.Println("\n4. Testing consumption from beginning (ALL messages)...")
        allFetchResult, err := consumer.FetchFrom("consume-test-topic", 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to fetch all messages: %v", err)
        }</span> else<span class="cov0" title="0"> if allFetchResult.Error != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to fetch all messages: %v", allFetchResult.Error)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✓ Successfully fetched %d total messages:\n", len(allFetchResult.Messages))
                singleCount := 0
                batchCount := 0

                for i, msg := range allFetchResult.Messages </span><span class="cov0" title="0">{
                        msgStr := string(msg.Value)
                        if len(msgStr) &gt; 0 &amp;&amp; msgStr[0:6] == "Single" </span><span class="cov0" title="0">{
                                singleCount++
                                fmt.Printf("  [%d] SINGLE: %s (Offset: %d)\n", i+1, msgStr, msg.Offset)
                        }</span> else<span class="cov0" title="0"> if len(msgStr) &gt; 0 &amp;&amp; msgStr[0:5] == "Batch" </span><span class="cov0" title="0">{
                                batchCount++
                                fmt.Printf("  [%d] BATCH:  %s (Offset: %d)\n", i+1, msgStr, msg.Offset)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("  [%d] OTHER:  %s (Offset: %d)\n", i+1, msgStr, msg.Offset)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("Summary: %d single messages, %d batch messages, %d total\n",
                        singleCount, batchCount, len(allFetchResult.Messages))
                fmt.Printf("Next Offset: %d\n", allFetchResult.NextOffset)</span>
        }

        // 5. Test partial batch consumption
        <span class="cov0" title="0">fmt.Println("\n5. Testing partial batch consumption...")
        if batchResult.Offset &gt;= 0 &amp;&amp; len(batchMessages) &gt;= 3 </span><span class="cov0" title="0">{
                // Consume only first 3 messages from the batch
                partialOffset := batchResult.Offset + 2 // Start from 3rd message in batch
                partialResult, err := consumer.FetchFrom("consume-test-topic", 0, partialOffset)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to fetch partial batch: %v", err)
                }</span> else<span class="cov0" title="0"> if partialResult.Error != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to fetch partial batch: %v", partialResult.Error)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✓ Partial consumption starting from offset %d:\n", partialOffset)
                        for i, msg := range partialResult.Messages </span><span class="cov0" title="0">{
                                fmt.Printf("  [%d]: %s (Offset: %d)\n", i+1, string(msg.Value), msg.Offset)
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Println("\n=== Consumer Protocol Fix Test COMPLETED SUCCESSFULLY! ===")
        fmt.Println("✓ Single message consumption: WORKING")
        fmt.Println("✓ Batch message consumption: WORKING")
        fmt.Println("✓ Protocol parsing errors: FIXED")
        fmt.Println("✓ Request type constants: ALIGNED")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cluster

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "path/filepath"
        "sync"
        "time"

        "github.com/lni/dragonboat/v3"
        "github.com/lni/dragonboat/v3/config"
        "github.com/lni/dragonboat/v3/logger"
        "github.com/lni/dragonboat/v3/statemachine"

        clusterConfig "github.com/issac1998/go-queue/internal/config"
        "github.com/issac1998/go-queue/internal/metadata"
)

const (
        ClusterID = 1 // 固定的集群ID
)

// Manager manages the cluster using Raft
type Manager struct {
        nodeID   uint64
        config   *clusterConfig.ClusterConfig
        nodeHost *dragonboat.NodeHost
        manager  *metadata.Manager

        mu       sync.RWMutex
        isLeader bool

        ctx    context.Context
        cancel context.CancelFunc
}

// NewManager creates a new cluster manager
func NewManager(nodeID uint64, clusterConf *clusterConfig.ClusterConfig, manager *metadata.Manager) (*Manager, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        cm := &amp;Manager{
                nodeID:  nodeID,
                config:  clusterConf,
                manager: manager,
                ctx:     ctx,
                cancel:  cancel,
        }

        if err := cm.initRaft(); err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to initialize Raft: %v", err)
        }</span>

        <span class="cov0" title="0">return cm, nil</span>
}

// initRaft initializes the Raft node
func (cm *Manager) initRaft() error <span class="cov0" title="0">{
        // 配置日志
        logger.GetLogger("raft").SetLevel(logger.WARNING)
        logger.GetLogger("rsm").SetLevel(logger.WARNING)
        logger.GetLogger("transport").SetLevel(logger.WARNING)
        logger.GetLogger("grpc").SetLevel(logger.WARNING)

        // 创建NodeHost配置
        nhConfig := config.NodeHostConfig{
                WALDir:         filepath.Join(cm.config.DataDir, "wal"),
                NodeHostDir:    filepath.Join(cm.config.DataDir, "nodehost"),
                RTTMillisecond: cm.config.HeartbeatRTT,
                RaftAddress:    cm.config.RaftAddress,
        }

        // 创建NodeHost
        nodeHost, err := dragonboat.NewNodeHost(nhConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create NodeHost: %v", err)
        }</span>
        <span class="cov0" title="0">cm.nodeHost = nodeHost

        // 创建Raft配置
        raftConfig := config.Config{
                NodeID:             cm.nodeID,
                ClusterID:          ClusterID,
                ElectionRTT:        cm.config.ElectionRTT,
                HeartbeatRTT:       cm.config.HeartbeatRTT,
                CheckQuorum:        cm.config.CheckQuorum,
                SnapshotEntries:    cm.config.SnapshotEntries,
                CompactionOverhead: cm.config.CompactionOverhead,
        }

        // 解析初始成员
        initialMembers := make(map[uint64]string)
        for i, addr := range cm.config.InitialMembers </span><span class="cov0" title="0">{
                initialMembers[uint64(i+1)] = addr
        }</span>

        // 启动Raft集群 - 使用v3的方式
        <span class="cov0" title="0">createStateMachine := func(clusterID uint64, nodeID uint64) statemachine.IStateMachine </span><span class="cov0" title="0">{
                return NewClusterStateMachine(nodeID, cm.manager)
        }</span>

        <span class="cov0" title="0">if err := cm.nodeHost.StartCluster(initialMembers, false, createStateMachine, raftConfig); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start cluster: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Raft cluster started - NodeID: %d, Address: %s", cm.nodeID, cm.config.RaftAddress)

        // 启动领导者检测
        go cm.leadershipMonitor()

        return nil</span>
}

// leadershipMonitor monitors leadership changes
func (cm *Manager) leadershipMonitor() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-cm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        leaderID, ok, err := cm.nodeHost.GetLeaderID(ClusterID)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to get leader ID: %v", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">cm.mu.Lock()
                        wasLeader := cm.isLeader
                        cm.isLeader = ok &amp;&amp; leaderID == cm.nodeID

                        if !wasLeader &amp;&amp; cm.isLeader </span><span class="cov0" title="0">{
                                log.Printf("Node %d became leader", cm.nodeID)
                                go cm.onBecomeLeader()
                        }</span> else<span class="cov0" title="0"> if wasLeader &amp;&amp; !cm.isLeader </span><span class="cov0" title="0">{
                                log.Printf("Node %d lost leadership", cm.nodeID)
                                go cm.onLoseLeader()
                        }</span>
                        <span class="cov0" title="0">cm.mu.Unlock()</span>
                }
        }
}

// onBecomeLeader handles becoming leader
func (cm *Manager) onBecomeLeader() <span class="cov0" title="0">{
        // 注册自己为broker
        broker := BrokerInfo{
                ID:       cm.nodeID,
                Address:  cm.config.RaftAddress, // 这里应该是业务地址
                RaftAddr: cm.config.RaftAddress,
                Status:   "alive",
        }

        if err := cm.RegisterBroker(&amp;broker); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to register broker: %v", err)
        }</span>
}

// onLoseLeader handles losing leadership
func (cm *Manager) onLoseLeader() <span class="cov0" title="0">{
        log.Printf("Node %d is no longer leader", cm.nodeID)
}</span>

// CreateTopic creates a new topic through Raft
func (cm *Manager) CreateTopic(name string, partitions, replicas int32) (*TopicInfo, error) <span class="cov0" title="0">{
        topicConfig := metadata.TopicConfig{
                Partitions: partitions,
                Replicas:   replicas,
        }

        configData, err := json.Marshal(topicConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">op := Operation{
                Type:  OpCreateTopic,
                Topic: name,
                Data:  configData,
        }

        result, err := cm.propose(&amp;op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var topicInfo TopicInfo
        if err := json.Unmarshal(result.Data, &amp;topicInfo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;topicInfo, nil</span>
}

// ProduceMessage produces a message through Raft
func (cm *Manager) ProduceMessage(topic string, partition int32, data []byte) error <span class="cov0" title="0">{
        op := Operation{
                Type:      OpAppendMessage,
                Topic:     topic,
                Partition: partition,
                Data:      data,
        }

        _, err := cm.propose(&amp;op)
        return err
}</span>

// RegisterBroker registers a broker in the cluster
func (cm *Manager) RegisterBroker(broker *BrokerInfo) error <span class="cov0" title="0">{
        data, err := json.Marshal(broker)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">op := Operation{
                Type: OpRegisterBroker,
                Data: data,
        }

        _, err = cm.propose(&amp;op)
        return err</span>
}

// GetClusterInfo gets cluster information
func (cm *Manager) GetClusterInfo() (*ClusterInfo, error) <span class="cov0" title="0">{
        // 查询brokers
        brokers, err := cm.query("brokers")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 查询topics
        <span class="cov0" title="0">topics, err := cm.query("topics")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">clusterInfo := &amp;ClusterInfo{
                Brokers: brokers.(map[uint64]*BrokerInfo),
                Topics:  topics.(map[string]*TopicInfo),
        }

        return clusterInfo, nil</span>
}

// IsLeader returns whether current node is leader
func (cm *Manager) IsLeader() bool <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        return cm.isLeader
}</span>

// GetLeaderID returns the current leader ID
func (cm *Manager) GetLeaderID() (uint64, bool, error) <span class="cov0" title="0">{
        return cm.nodeHost.GetLeaderID(ClusterID)
}</span>

// propose proposes an operation to the Raft cluster
func (cm *Manager) propose(op *Operation) (*statemachine.Result, error) <span class="cov0" title="0">{
        data, err := json.Marshal(op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        session := cm.nodeHost.GetNoOPSession(ClusterID)
        result, err := cm.nodeHost.SyncPropose(ctx, session, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;statemachine.Result{
                Value: result.Value,
                Data:  result.Data,
        }, nil</span>
}

// query performs a read-only query
func (cm *Manager) query(queryType string) (interface{}, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        result, err := cm.nodeHost.SyncRead(ctx, ClusterID, queryType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Stop stops the cluster manager
func (cm *Manager) Stop() error <span class="cov0" title="0">{
        cm.cancel()

        if cm.nodeHost != nil </span><span class="cov0" title="0">{
                cm.nodeHost.Stop()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ClusterInfo represents cluster information
type ClusterInfo struct {
        Brokers map[uint64]*BrokerInfo `json:"brokers"`
        Topics  map[string]*TopicInfo  `json:"topics"`
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cluster

import (
        "encoding/json"
        "fmt"
        "io"
        "sync"

        "github.com/issac1998/go-queue/internal/metadata"
        sm "github.com/lni/dragonboat/v3/statemachine"
)

// 操作类型
const (
        OpCreateTopic      = 1
        OpDeleteTopic      = 2
        OpAppendMessage    = 3
        OpUpdateMetadata   = 4
        OpRegisterBroker   = 5
        OpUnregisterBroker = 6
)

// Operation represents a state machine operation
type Operation struct {
        Type      uint32      `json:"type"`
        Topic     string      `json:"topic,omitempty"`
        Partition int32       `json:"partition,omitempty"`
        Data      []byte      `json:"data,omitempty"`
        Metadata  interface{} `json:"metadata,omitempty"`
}

// ClusterStateMachine implements the Raft state machine
type ClusterStateMachine struct {
        nodeID uint64
        mu     sync.RWMutex

        // 集群元数据
        brokers    map[uint64]*BrokerInfo
        topics     map[string]*TopicInfo
        partitions map[string]map[int32]*PartitionInfo

        // 本地数据管理器
        manager *metadata.Manager
}

// BrokerInfo represents broker information
type BrokerInfo struct {
        ID       uint64 `json:"id"`
        Address  string `json:"address"`
        RaftAddr string `json:"raft_addr"`
        Status   string `json:"status"`
}

// TopicInfo represents topic information
type TopicInfo struct {
        Name       string `json:"name"`
        Partitions int32  `json:"partitions"`
        Replicas   int32  `json:"replicas"`
}

// PartitionInfo represents partition information
type PartitionInfo struct {
        Topic    string   `json:"topic"`
        ID       int32    `json:"id"`
        Leader   uint64   `json:"leader"`
        Replicas []uint64 `json:"replicas"`
        ISR      []uint64 `json:"isr"`
}

// NewClusterStateMachine creates a new cluster state machine
func NewClusterStateMachine(nodeID uint64, manager *metadata.Manager) sm.IStateMachine <span class="cov0" title="0">{
        return &amp;ClusterStateMachine{
                nodeID:     nodeID,
                brokers:    make(map[uint64]*BrokerInfo),
                topics:     make(map[string]*TopicInfo),
                partitions: make(map[string]map[int32]*PartitionInfo),
                manager:    manager,
        }
}</span>

// Update updates the state machine (dragonboat v3 interface)
func (csm *ClusterStateMachine) Update(data []byte) (sm.Result, error) <span class="cov0" title="0">{
        var op Operation
        if err := json.Unmarshal(data, &amp;op); err != nil </span><span class="cov0" title="0">{
                return sm.Result{Value: 0}, err
        }</span>

        <span class="cov0" title="0">result, err := csm.applyOperation(&amp;op)
        if err != nil </span><span class="cov0" title="0">{
                return sm.Result{Value: 0}, err
        }</span>

        // 返回成功结果
        <span class="cov0" title="0">return sm.Result{
                Value: 1,
                Data:  result,
        }, nil</span>
}

// Lookup performs a read-only query (dragonboat v3 interface)
func (csm *ClusterStateMachine) Lookup(query interface{}) (interface{}, error) <span class="cov0" title="0">{
        csm.mu.RLock()
        defer csm.mu.RUnlock()

        switch q := query.(type) </span>{
        case string:<span class="cov0" title="0">
                switch q </span>{
                case "brokers":<span class="cov0" title="0">
                        return csm.brokers, nil</span>
                case "topics":<span class="cov0" title="0">
                        return csm.topics, nil</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unknown query type: %s", q)</span>
                }
        case []byte:<span class="cov0" title="0">
                queryStr := string(q)
                switch queryStr </span>{
                case "brokers":<span class="cov0" title="0">
                        return csm.brokers, nil</span>
                case "topics":<span class="cov0" title="0">
                        return csm.topics, nil</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unknown query type: %s", queryStr)</span>
                }
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported query type")</span>
        }
}

// SaveSnapshot saves the current state as a snapshot (dragonboat v3 interface)
func (csm *ClusterStateMachine) SaveSnapshot(w io.Writer, fc sm.ISnapshotFileCollection, done &lt;-chan struct{}) error <span class="cov0" title="0">{
        csm.mu.RLock()
        defer csm.mu.RUnlock()

        snapshot := struct {
                Brokers    map[uint64]*BrokerInfo              `json:"brokers"`
                Topics     map[string]*TopicInfo               `json:"topics"`
                Partitions map[string]map[int32]*PartitionInfo `json:"partitions"`
        }{
                Brokers:    csm.brokers,
                Topics:     csm.topics,
                Partitions: csm.partitions,
        }

        data, err := json.Marshal(snapshot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = w.Write(data)
        return err</span>
}

// RecoverFromSnapshot recovers state from a snapshot (dragonboat v3 interface)
func (csm *ClusterStateMachine) RecoverFromSnapshot(r io.Reader, files []sm.SnapshotFile, done &lt;-chan struct{}) error <span class="cov0" title="0">{
        csm.mu.Lock()
        defer csm.mu.Unlock()

        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var snapshot struct {
                Brokers    map[uint64]*BrokerInfo              `json:"brokers"`
                Topics     map[string]*TopicInfo               `json:"topics"`
                Partitions map[string]map[int32]*PartitionInfo `json:"partitions"`
        }

        if err := json.Unmarshal(data, &amp;snapshot); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">csm.brokers = snapshot.Brokers
        csm.topics = snapshot.Topics
        csm.partitions = snapshot.Partitions

        return nil</span>
}

// Close closes the state machine (dragonboat v3 interface)
func (csm *ClusterStateMachine) Close() error <span class="cov0" title="0">{
        // 清理资源
        return nil
}</span>

// GetHash returns a hash of the current state (dragonboat v3 interface)
func (csm *ClusterStateMachine) GetHash() uint64 <span class="cov0" title="0">{
        csm.mu.RLock()
        defer csm.mu.RUnlock()

        // 简化的哈希实现，实际应该更复杂
        return uint64(len(csm.brokers) + len(csm.topics))
}</span>

// applyOperation applies an operation to the state machine
func (csm *ClusterStateMachine) applyOperation(op *Operation) ([]byte, error) <span class="cov0" title="0">{
        csm.mu.Lock()
        defer csm.mu.Unlock()

        switch op.Type </span>{
        case OpCreateTopic:<span class="cov0" title="0">
                return csm.createTopic(op)</span>
        case OpDeleteTopic:<span class="cov0" title="0">
                return csm.deleteTopic(op)</span>
        case OpAppendMessage:<span class="cov0" title="0">
                return csm.appendMessage(op)</span>
        case OpUpdateMetadata:<span class="cov0" title="0">
                return csm.updateMetadata(op)</span>
        case OpRegisterBroker:<span class="cov0" title="0">
                return csm.registerBroker(op)</span>
        case OpUnregisterBroker:<span class="cov0" title="0">
                return csm.unregisterBroker(op)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown operation type: %d", op.Type)</span>
        }
}

// createTopic creates a new topic
func (csm *ClusterStateMachine) createTopic(op *Operation) ([]byte, error) <span class="cov0" title="0">{
        var topicConfig metadata.TopicConfig
        if err := json.Unmarshal(op.Data, &amp;topicConfig); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 检查topic是否已存在
        <span class="cov0" title="0">if _, exists := csm.topics[op.Topic]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("topic %s already exists", op.Topic)
        }</span>

        // 创建topic信息
        <span class="cov0" title="0">topicInfo := &amp;TopicInfo{
                Name:       op.Topic,
                Partitions: topicConfig.Partitions,
                Replicas:   topicConfig.Replicas,
        }
        csm.topics[op.Topic] = topicInfo

        // 创建分区信息
        csm.partitions[op.Topic] = make(map[int32]*PartitionInfo)
        brokerList := csm.getAliveBrokers()

        for i := int32(0); i &lt; topicConfig.Partitions; i++ </span><span class="cov0" title="0">{
                replicas := csm.assignReplicas(brokerList, int(topicConfig.Replicas))
                partitionInfo := &amp;PartitionInfo{
                        Topic:    op.Topic,
                        ID:       i,
                        Leader:   replicas[0], // 第一个副本作为Leader
                        Replicas: replicas,
                        ISR:      replicas, // 初始时所有副本都在ISR中
                }
                csm.partitions[op.Topic][i] = partitionInfo
        }</span>

        // 在本地Manager中创建topic
        <span class="cov0" title="0">if csm.manager != nil </span><span class="cov0" title="0">{
                _, err := csm.manager.CreateTopic(op.Topic, &amp;topicConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create topic in local manager: %v", err)
                }</span>
        }

        <span class="cov0" title="0">result, _ := json.Marshal(topicInfo)
        return result, nil</span>
}

// deleteTopic deletes a topic
func (csm *ClusterStateMachine) deleteTopic(op *Operation) ([]byte, error) <span class="cov0" title="0">{
        if _, exists := csm.topics[op.Topic]; !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("topic %s not found", op.Topic)
        }</span>

        <span class="cov0" title="0">delete(csm.topics, op.Topic)
        delete(csm.partitions, op.Topic)

        return []byte("OK"), nil</span>
}

// appendMessage appends a message to a partition
func (csm *ClusterStateMachine) appendMessage(op *Operation) ([]byte, error) <span class="cov0" title="0">{
        partitionMap, exists := csm.partitions[op.Topic]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("topic %s not found", op.Topic)
        }</span>

        <span class="cov0" title="0">partitionInfo, exists := partitionMap[op.Partition]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("partition %d not found for topic %s", op.Partition, op.Topic)
        }</span>

        // 检查当前节点是否为该分区的Leader
        <span class="cov0" title="0">if partitionInfo.Leader != csm.nodeID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not the leader for partition %d of topic %s", op.Partition, op.Topic)
        }</span>

        // 在本地Manager中写入消息
        <span class="cov0" title="0">if csm.manager != nil </span><span class="cov0" title="0">{
                offset, err := csm.manager.WriteMessage(op.Topic, op.Partition, op.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write message: %v", err)
                }</span>

                <span class="cov0" title="0">result := struct {
                        Offset int64 `json:"offset"`
                }{
                        Offset: offset,
                }
                resultBytes, _ := json.Marshal(result)
                return resultBytes, nil</span>
        }

        <span class="cov0" title="0">return []byte("OK"), nil</span>
}

// updateMetadata updates cluster metadata
func (csm *ClusterStateMachine) updateMetadata(op *Operation) ([]byte, error) <span class="cov0" title="0">{
        // 处理元数据更新逻辑
        return []byte("OK"), nil
}</span>

// registerBroker registers a new broker
func (csm *ClusterStateMachine) registerBroker(op *Operation) ([]byte, error) <span class="cov0" title="0">{
        var broker BrokerInfo
        if err := json.Unmarshal(op.Data, &amp;broker); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">csm.brokers[broker.ID] = &amp;broker
        return []byte("OK"), nil</span>
}

// unregisterBroker unregisters a broker
func (csm *ClusterStateMachine) unregisterBroker(op *Operation) ([]byte, error) <span class="cov0" title="0">{
        var brokerID uint64
        if err := json.Unmarshal(op.Data, &amp;brokerID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">delete(csm.brokers, brokerID)
        return []byte("OK"), nil</span>
}

// getAliveBrokers returns list of alive broker IDs
func (csm *ClusterStateMachine) getAliveBrokers() []uint64 <span class="cov0" title="0">{
        var brokers []uint64
        for id, broker := range csm.brokers </span><span class="cov0" title="0">{
                if broker.Status == "alive" </span><span class="cov0" title="0">{
                        brokers = append(brokers, id)
                }</span>
        }
        <span class="cov0" title="0">return brokers</span>
}

// assignReplicas assigns replicas for a partition
func (csm *ClusterStateMachine) assignReplicas(brokers []uint64, replicaCount int) []uint64 <span class="cov0" title="0">{
        if len(brokers) == 0 </span><span class="cov0" title="0">{
                return []uint64{csm.nodeID} // 如果没有其他broker，使用自己
        }</span>

        <span class="cov0" title="0">if replicaCount &gt; len(brokers) </span><span class="cov0" title="0">{
                replicaCount = len(brokers)
        }</span>

        <span class="cov0" title="0">replicas := make([]uint64, replicaCount)
        for i := 0; i &lt; replicaCount; i++ </span><span class="cov0" title="0">{
                replicas[i] = brokers[i%len(brokers)]
        }</span>

        <span class="cov0" title="0">return replicas</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package compression

import (
        "bytes"
        "compress/gzip"
        "compress/zlib"
        "fmt"
        "io"

        "github.com/klauspost/compress/snappy"
        "github.com/klauspost/compress/zstd"
)

// CompressionType 压缩类型
type CompressionType int8

const (
        None CompressionType = iota
        Gzip
        Zlib
        Snappy
        Zstd
)

func (c CompressionType) String() string <span class="cov0" title="0">{
        switch c </span>{
        case None:<span class="cov0" title="0">
                return "none"</span>
        case Gzip:<span class="cov0" title="0">
                return "gzip"</span>
        case Zlib:<span class="cov0" title="0">
                return "zlib"</span>
        case Snappy:<span class="cov0" title="0">
                return "snappy"</span>
        case Zstd:<span class="cov0" title="0">
                return "zstd"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Compressor 压缩器接口
type Compressor interface {
        Compress(data []byte) ([]byte, error)
        Decompress(data []byte) ([]byte, error)
        Type() CompressionType
}

// NoCompression 无压缩
type NoCompression struct{}

func (n *NoCompression) Compress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        return data, nil
}</span>

func (n *NoCompression) Decompress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        return data, nil
}</span>

func (n *NoCompression) Type() CompressionType <span class="cov0" title="0">{
        return None
}</span>

// GzipCompression Gzip压缩
type GzipCompression struct{}

func (g *GzipCompression) Compress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        writer := gzip.NewWriter(&amp;buf)

        if _, err := writer.Write(data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gzip compress failed: %v", err)
        }</span>

        <span class="cov0" title="0">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gzip writer close failed: %v", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (g *GzipCompression) Decompress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        reader, err := gzip.NewReader(bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gzip reader create failed: %v", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        result, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gzip decompress failed: %v", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (g *GzipCompression) Type() CompressionType <span class="cov0" title="0">{
        return Gzip
}</span>

// ZlibCompression Zlib压缩
type ZlibCompression struct{}

func (z *ZlibCompression) Compress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        writer := zlib.NewWriter(&amp;buf)

        if _, err := writer.Write(data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("zlib compress failed: %v", err)
        }</span>

        <span class="cov0" title="0">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("zlib writer close failed: %v", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (z *ZlibCompression) Decompress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        reader, err := zlib.NewReader(bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("zlib reader create failed: %v", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        result, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("zlib decompress failed: %v", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (z *ZlibCompression) Type() CompressionType <span class="cov0" title="0">{
        return Zlib
}</span>

// SnappyCompression Snappy压缩
type SnappyCompression struct{}

func (s *SnappyCompression) Compress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        return snappy.Encode(nil, data), nil
}</span>

func (s *SnappyCompression) Decompress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        result, err := snappy.Decode(nil, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("snappy decompress failed: %v", err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (s *SnappyCompression) Type() CompressionType <span class="cov0" title="0">{
        return Snappy
}</span>

// ZstdCompression Zstd压缩
type ZstdCompression struct {
        encoder *zstd.Encoder
        decoder *zstd.Decoder
}

func NewZstdCompression() (*ZstdCompression, error) <span class="cov0" title="0">{
        encoder, err := zstd.NewWriter(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create zstd encoder failed: %v", err)
        }</span>

        <span class="cov0" title="0">decoder, err := zstd.NewReader(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create zstd decoder failed: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;ZstdCompression{
                encoder: encoder,
                decoder: decoder,
        }, nil</span>
}

func (z *ZstdCompression) Compress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        return z.encoder.EncodeAll(data, nil), nil
}</span>

func (z *ZstdCompression) Decompress(data []byte) ([]byte, error) <span class="cov0" title="0">{
        result, err := z.decoder.DecodeAll(data, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("zstd decompress failed: %v", err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (z *ZstdCompression) Type() CompressionType <span class="cov0" title="0">{
        return Zstd
}</span>

func (z *ZstdCompression) Close() <span class="cov0" title="0">{
        if z.encoder != nil </span><span class="cov0" title="0">{
                z.encoder.Close()
        }</span>
        <span class="cov0" title="0">if z.decoder != nil </span><span class="cov0" title="0">{
                z.decoder.Close()
        }</span>
}

// GetCompressor 根据类型获取压缩器
func GetCompressor(compressionType CompressionType) (Compressor, error) <span class="cov0" title="0">{
        switch compressionType </span>{
        case None:<span class="cov0" title="0">
                return &amp;NoCompression{}, nil</span>
        case Gzip:<span class="cov0" title="0">
                return &amp;GzipCompression{}, nil</span>
        case Zlib:<span class="cov0" title="0">
                return &amp;ZlibCompression{}, nil</span>
        case Snappy:<span class="cov0" title="0">
                return &amp;SnappyCompression{}, nil</span>
        case Zstd:<span class="cov0" title="0">
                return NewZstdCompression()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported compression type: %d", compressionType)</span>
        }
}

// CompressMessage 压缩消息，返回带压缩头的数据
func CompressMessage(data []byte, compressionType CompressionType) ([]byte, error) <span class="cov0" title="0">{
        compressor, err := GetCompressor(compressionType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">compressed, err := compressor.Compress(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 添加压缩类型头(1字节) + 原始长度(4字节) + 压缩数据
        <span class="cov0" title="0">result := make([]byte, 5+len(compressed))
        result[0] = byte(compressionType)

        // 写入原始数据长度
        originalLen := uint32(len(data))
        result[1] = byte(originalLen &gt;&gt; 24)
        result[2] = byte(originalLen &gt;&gt; 16)
        result[3] = byte(originalLen &gt;&gt; 8)
        result[4] = byte(originalLen)

        copy(result[5:], compressed)

        return result, nil</span>
}

// DecompressMessage 解压缩消息
func DecompressMessage(data []byte) ([]byte, error) <span class="cov0" title="0">{
        if len(data) &lt; 5 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid compressed data: too short")
        }</span>

        <span class="cov0" title="0">compressionType := CompressionType(data[0])

        // 读取原始长度
        originalLen := uint32(data[1])&lt;&lt;24 | uint32(data[2])&lt;&lt;16 | uint32(data[3])&lt;&lt;8 | uint32(data[4])

        compressor, err := GetCompressor(compressionType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">decompressed, err := compressor.Decompress(data[5:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 验证长度
        <span class="cov0" title="0">if uint32(len(decompressed)) != originalLen </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decompressed data length mismatch: expected %d, got %d",
                        originalLen, len(decompressed))
        }</span>

        <span class="cov0" title="0">return decompressed, nil</span>
}

// CalculateCompressionRatio 计算压缩比
func CalculateCompressionRatio(originalSize, compressedSize int) float64 <span class="cov0" title="0">{
        if originalSize == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(compressedSize) / float64(originalSize)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "time"

        "github.com/issac1998/go-queue/internal/compression"
        "github.com/issac1998/go-queue/internal/deduplication"
        "github.com/issac1998/go-queue/internal/metadata"
)

// BrokerConfig represents the complete broker configuration
type BrokerConfig struct {
        *metadata.Config
        Server  ServerConfig  `json:"server"`
        Cluster ClusterConfig `json:"cluster"`
}

// ServerConfig represents server-specific configuration
type ServerConfig struct {
        Port    string `json:"port"`
        LogFile string `json:"log_file"`
}

// ClusterConfig represents cluster and Raft configuration
type ClusterConfig struct {
        Enabled        bool     `json:"enabled"`
        NodeID         uint64   `json:"node_id"`
        RaftAddress    string   `json:"raft_address"`
        InitialMembers []string `json:"initial_members"`
        DataDir        string   `json:"data_dir"`

        // Raft配置
        ElectionRTT        uint64 `json:"election_rtt"`
        HeartbeatRTT       uint64 `json:"heartbeat_rtt"`
        CheckQuorum        bool   `json:"check_quorum"`
        SnapshotEntries    uint64 `json:"snapshot_entries"`
        CompactionOverhead uint64 `json:"compaction_overhead"`
}

// ClientConfig represents client configuration
type ClientConfig struct {
        Broker  string        `json:"broker"`
        Timeout string        `json:"timeout"`
        LogFile string        `json:"log_file"`
        Command CommandConfig `json:"command"`
}

// CommandConfig represents command-specific configuration
type CommandConfig struct {
        Type      string `json:"type"`
        Topic     string `json:"topic"`
        Partition int    `json:"partition"`
        Message   string `json:"message"`
        Offset    int64  `json:"offset"`
        Count     int    `json:"count"`
}

// deduplicationConfigJSON is a temporary struct for JSON parsing
type deduplicationConfigJSON struct {
        HashType   deduplication.HashType `json:"hash_type"`
        MaxEntries int                    `json:"max_entries"`
        TTL        string                 `json:"ttl"`
        Enabled    bool                   `json:"enabled"`
}

// brokerConfigJSON is a temporary struct for JSON parsing
type brokerConfigJSON struct {
        DataDir            string `json:"data_dir"`
        MaxTopicPartitions int    `json:"max_topic_partitions"`
        SegmentSize        int64  `json:"segment_size"`
        RetentionTime      string `json:"retention_time"`
        MaxStorageSize     int64  `json:"max_storage_size"`
        FlushInterval      string `json:"flush_interval"`
        CleanupInterval    string `json:"cleanup_interval"`
        MaxMessageSize     int    `json:"max_message_size"`

        CompressionEnabled   bool                        `json:"compression_enabled"`
        CompressionType      compression.CompressionType `json:"compression_type"`
        CompressionThreshold int                         `json:"compression_threshold"`

        DeduplicationEnabled bool                     `json:"deduplication_enabled"`
        DeduplicationConfig  *deduplicationConfigJSON `json:"deduplication_config"`

        Server  ServerConfig  `json:"server"`
        Cluster ClusterConfig `json:"cluster"`
}

// LoadBrokerConfig loads broker configuration from JSON file
func LoadBrokerConfig(configPath string) (*BrokerConfig, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %v", err)
        }</span>

        <span class="cov0" title="0">var configJSON brokerConfigJSON
        if err := json.Unmarshal(data, &amp;configJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %v", err)
        }</span>

        // Parse duration fields
        <span class="cov0" title="0">retentionTime, err := time.ParseDuration(configJSON.RetentionTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid retention_time: %v", err)
        }</span>

        <span class="cov0" title="0">flushInterval, err := time.ParseDuration(configJSON.FlushInterval)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid flush_interval: %v", err)
        }</span>

        <span class="cov0" title="0">cleanupInterval, err := time.ParseDuration(configJSON.CleanupInterval)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid cleanup_interval: %v", err)
        }</span>

        // Parse deduplication config if provided
        <span class="cov0" title="0">var dedupConfig *deduplication.Config
        if configJSON.DeduplicationConfig != nil </span><span class="cov0" title="0">{
                ttl, err := time.ParseDuration(configJSON.DeduplicationConfig.TTL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid deduplication ttl: %v", err)
                }</span>

                <span class="cov0" title="0">dedupConfig = &amp;deduplication.Config{
                        HashType:   configJSON.DeduplicationConfig.HashType,
                        MaxEntries: configJSON.DeduplicationConfig.MaxEntries,
                        TTL:        ttl,
                        Enabled:    configJSON.DeduplicationConfig.Enabled,
                }</span>
        }

        // Create the final config
        <span class="cov0" title="0">config := &amp;BrokerConfig{
                Config: &amp;metadata.Config{
                        DataDir:            configJSON.DataDir,
                        MaxTopicPartitions: configJSON.MaxTopicPartitions,
                        SegmentSize:        configJSON.SegmentSize,
                        RetentionTime:      retentionTime,
                        MaxStorageSize:     configJSON.MaxStorageSize,
                        FlushInterval:      flushInterval,
                        CleanupInterval:    cleanupInterval,
                        MaxMessageSize:     configJSON.MaxMessageSize,

                        CompressionEnabled:   configJSON.CompressionEnabled,
                        CompressionType:      configJSON.CompressionType,
                        CompressionThreshold: configJSON.CompressionThreshold,

                        DeduplicationEnabled: configJSON.DeduplicationEnabled,
                        DeduplicationConfig:  dedupConfig,
                },
                Server:  configJSON.Server,
                Cluster: configJSON.Cluster,
        }

        // Set defaults if not provided
        if config.Server.Port == "" </span><span class="cov0" title="0">{
                config.Server.Port = "9092"
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// LoadClientConfig loads client configuration from JSON file
func LoadClientConfig(configPath string) (*ClientConfig, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %v", err)
        }</span>

        <span class="cov0" title="0">var config ClientConfig
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %v", err)
        }</span>

        // Set defaults if not provided
        <span class="cov0" title="0">if config.Broker == "" </span><span class="cov0" title="0">{
                config.Broker = "localhost:9092"
        }</span>
        <span class="cov0" title="0">if config.Timeout == "" </span><span class="cov0" title="0">{
                config.Timeout = "10s"
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// GetTimeoutDuration parses timeout string to duration
func (c *ClientConfig) GetTimeoutDuration() (time.Duration, error) <span class="cov0" title="0">{
        return time.ParseDuration(c.Timeout)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package deduplication

import (
        "crypto/md5"
        "crypto/sha256"
        "encoding/hex"
        "hash"
        "sync"
        "time"
)

// HashType 哈希算法类型
type HashType int8

const (
        MD5 HashType = iota
        SHA256
)

func (h HashType) String() string <span class="cov0" title="0">{
        switch h </span>{
        case MD5:<span class="cov0" title="0">
                return "md5"</span>
        case SHA256:<span class="cov0" title="0">
                return "sha256"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// DuplicateEntry duplicate entry information
type DuplicateEntry struct {
        Hash      string    `json:"hash"`
        FirstSeen time.Time `json:"first_seen"`
        Count     int64     `json:"count"`
        LastSeen  time.Time `json:"last_seen"`
        Offset    int64     `json:"offset"` // first occurrence offset
}

// Deduplicator duplicate message deduplicator
type Deduplicator struct {
        hashType    HashType
        entries     map[string]*DuplicateEntry
        mu          sync.RWMutex
        maxEntries  int           // maximum number of entries
        ttl         time.Duration // entry TTL
        enabled     bool
        cleanupTick *time.Ticker
        stopCh      chan struct{}
}

// Config duplicate message deduplicator configuration
type Config struct {
        HashType   HashType      `json:"hash_type"`
        MaxEntries int           `json:"max_entries"`
        TTL        time.Duration `json:"ttl"`
        Enabled    bool          `json:"enabled"`
}

// DefaultConfig returns the default deduplicator configuration
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                HashType:   SHA256,
                MaxEntries: 100000,         // 100,000 entries
                TTL:        time.Hour * 24, // 24 hours
                Enabled:    true,
        }
}</span>

// NewDeduplicator creates a new Deduplicator
func NewDeduplicator(config *Config) *Deduplicator <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        <span class="cov0" title="0">d := &amp;Deduplicator{
                hashType:   config.HashType,
                entries:    make(map[string]*DuplicateEntry),
                maxEntries: config.MaxEntries,
                ttl:        config.TTL,
                enabled:    config.Enabled,
                stopCh:     make(chan struct{}),
        }

        if d.enabled &amp;&amp; d.ttl &gt; 0 </span><span class="cov0" title="0">{
                d.startCleanup()
        }</span>

        <span class="cov0" title="0">return d</span>
}

// IsEnabled checks whether deduplication is enabled
func (d *Deduplicator) IsEnabled() bool <span class="cov0" title="0">{
        return d.enabled
}</span>

// Enable enables deduplication
func (d *Deduplicator) Enable() <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()
        d.enabled = true
        if d.cleanupTick == nil &amp;&amp; d.ttl &gt; 0 </span><span class="cov0" title="0">{
                d.startCleanup()
        }</span>
}

// Disable disables deduplication
func (d *Deduplicator) Disable() <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()
        d.enabled = false
        if d.cleanupTick != nil </span><span class="cov0" title="0">{
                d.cleanupTick.Stop()
                d.cleanupTick = nil
        }</span>
}

// calculateHash calculates the hash of the message
func (d *Deduplicator) calculateHash(data []byte) string <span class="cov0" title="0">{
        var hasher hash.Hash

        switch d.hashType </span>{
        case MD5:<span class="cov0" title="0">
                hasher = md5.New()</span>
        case SHA256:<span class="cov0" title="0">
                hasher = sha256.New()</span>
        default:<span class="cov0" title="0">
                hasher = sha256.New()</span>
        }

        <span class="cov0" title="0">hasher.Write(data)
        return hex.EncodeToString(hasher.Sum(nil))</span>
}

// IsDuplicate checks whether the message is a duplicate
// 返回: isDuplicate, originalOffset, error
func (d *Deduplicator) IsDuplicate(data []byte, currentOffset int64) (bool, int64, error) <span class="cov0" title="0">{
        if !d.enabled </span><span class="cov0" title="0">{
                return false, -1, nil
        }</span>

        <span class="cov0" title="0">hash := d.calculateHash(data)

        d.mu.Lock()
        defer d.mu.Unlock()

        entry, exists := d.entries[hash]
        if exists </span><span class="cov0" title="0">{
                // 更新统计信息
                entry.Count++
                entry.LastSeen = time.Now()
                return true, entry.Offset, nil
        }</span>

        // if entries exceed max, evict oldest
        <span class="cov0" title="0">if len(d.entries) &gt;= d.maxEntries </span><span class="cov0" title="0">{
                d.evictOldest()
        }</span>

        // 添加新条目
        <span class="cov0" title="0">now := time.Now()
        d.entries[hash] = &amp;DuplicateEntry{
                Hash:      hash,
                FirstSeen: now,
                Count:     1,
                LastSeen:  now,
                Offset:    currentOffset,
        }

        return false, -1, nil</span>
}

// GetDuplicateInfo 获取重复消息信息
func (d *Deduplicator) GetDuplicateInfo(data []byte) *DuplicateEntry <span class="cov0" title="0">{
        if !d.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">hash := d.calculateHash(data)

        d.mu.RLock()
        defer d.mu.RUnlock()

        entry, exists := d.entries[hash]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 返回副本避免并发修改
        <span class="cov0" title="0">return &amp;DuplicateEntry{
                Hash:      entry.Hash,
                FirstSeen: entry.FirstSeen,
                Count:     entry.Count,
                LastSeen:  entry.LastSeen,
                Offset:    entry.Offset,
        }</span>
}

// evictOldest 淘汰最老的条目
func (d *Deduplicator) evictOldest() <span class="cov0" title="0">{
        var oldestHash string
        var oldestTime time.Time

        for hash, entry := range d.entries </span><span class="cov0" title="0">{
                if oldestHash == "" || entry.FirstSeen.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestHash = hash
                        oldestTime = entry.FirstSeen
                }</span>
        }

        <span class="cov0" title="0">if oldestHash != "" </span><span class="cov0" title="0">{
                delete(d.entries, oldestHash)
        }</span>
}

// startCleanup starts the cleanup goroutine
func (d *Deduplicator) startCleanup() <span class="cov0" title="0">{
        cleanupInterval := d.ttl / 10 // clean up every 1/10 of TTL
        if cleanupInterval &lt; time.Minute </span><span class="cov0" title="0">{
                cleanupInterval = time.Minute
        }</span>

        <span class="cov0" title="0">d.cleanupTick = time.NewTicker(cleanupInterval)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-d.cleanupTick.C:<span class="cov0" title="0">
                                d.cleanup()</span>
                        case &lt;-d.stopCh:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

// cleanup cleans up old entries
func (d *Deduplicator) cleanup() <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        now := time.Now()
        expiredHashes := make([]string, 0)

        for hash, entry := range d.entries </span><span class="cov0" title="0">{
                if now.Sub(entry.LastSeen) &gt; d.ttl </span><span class="cov0" title="0">{
                        expiredHashes = append(expiredHashes, hash)
                }</span>
        }

        <span class="cov0" title="0">for _, hash := range expiredHashes </span><span class="cov0" title="0">{
                delete(d.entries, hash)
        }</span>
}

// GetStats returns the current deduplicator statistics
func (d *Deduplicator) GetStats() *Stats <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        totalCount := int64(0)
        totalDuplicates := int64(0)

        for _, entry := range d.entries </span><span class="cov0" title="0">{
                totalCount += entry.Count
                if entry.Count &gt; 1 </span><span class="cov0" title="0">{
                        totalDuplicates += entry.Count - 1 // 减去第一次出现
                }</span>
        }

        <span class="cov0" title="0">return &amp;Stats{
                UniqueMessages:    int64(len(d.entries)),
                TotalMessages:     totalCount,
                DuplicateMessages: totalDuplicates,
                DuplicateRate:     float64(totalDuplicates) / float64(totalCount),
                HashType:          d.hashType.String(),
                Enabled:           d.enabled,
        }</span>
}

// Stats duplicate message deduplication statistics
type Stats struct {
        UniqueMessages    int64   `json:"unique_messages"`
        TotalMessages     int64   `json:"total_messages"`
        DuplicateMessages int64   `json:"duplicate_messages"`
        DuplicateRate     float64 `json:"duplicate_rate"`
        HashType          string  `json:"hash_type"`
        Enabled           bool    `json:"enabled"`
}

// Clear 1
func (d *Deduplicator) Clear() <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()
        d.entries = make(map[string]*DuplicateEntry)
}</span>

// Close
func (d *Deduplicator) Close() <span class="cov0" title="0">{
        if d.cleanupTick != nil </span><span class="cov0" title="0">{
                d.cleanupTick.Stop()
        }</span>
        <span class="cov0" title="0">close(d.stopCh)</span>
}

// Todo: Add persistence of deduplication entries to disk for recovery after restart
// CalculateMessageHash calculate the hash of the message using the specified hash type
func CalculateMessageHash(data []byte, hashType HashType) string <span class="cov0" title="0">{
        var hasher hash.Hash

        switch hashType </span>{
        case MD5:<span class="cov0" title="0">
                hasher = md5.New()</span>
        case SHA256:<span class="cov0" title="0">
                hasher = sha256.New()</span>
        default:<span class="cov0" title="0">
                hasher = sha256.New()</span>
        }

        <span class="cov0" title="0">hasher.Write(data)
        return hex.EncodeToString(hasher.Sum(nil))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package metadata

import (
        "fmt"
        "sync"
        "time"
)

// ConsumerGroup 消费者组
type ConsumerGroup struct {
        ID         string               `json:"id"`         // 消费者组ID
        Members    map[string]*Consumer `json:"members"`    // 组内消费者
        Partitions map[string][]int32   `json:"partitions"` // Topic -&gt; 分区列表
        State      GroupState           `json:"state"`      // 组状态
        Protocol   string               `json:"protocol"`   // 分区分配协议
        Leader     string               `json:"leader"`     // 组Leader ID
        Generation int32                `json:"generation"` // 组世代
        CreatedAt  time.Time            `json:"created_at"`
        UpdatedAt  time.Time            `json:"updated_at"`
        mu         sync.RWMutex
}

// Consumer 消费者
type Consumer struct {
        ID             string             `json:"id"`              // 消费者ID
        ClientID       string             `json:"client_id"`       // 客户端ID
        GroupID        string             `json:"group_id"`        // 所属消费者组
        Subscriptions  []string           `json:"subscriptions"`   // 订阅的Topic列表
        Assignment     map[string][]int32 `json:"assignment"`      // 分配的分区 Topic -&gt; 分区列表
        LastHeartbeat  time.Time          `json:"last_heartbeat"`  // 最后心跳时间
        SessionTimeout time.Duration      `json:"session_timeout"` // 会话超时时间
        JoinedAt       time.Time          `json:"joined_at"`
        mu             sync.RWMutex
}

// GroupState 消费者组状态
type GroupState int32

const (
        GroupStateEmpty               GroupState = iota // 空组
        GroupStateStable                                // 稳定状态
        GroupStatePreparingRebalance                    // 准备重平衡
        GroupStateCompletingRebalance                   // 完成重平衡
)

func (s GroupState) String() string <span class="cov0" title="0">{
        switch s </span>{
        case GroupStateEmpty:<span class="cov0" title="0">
                return "Empty"</span>
        case GroupStateStable:<span class="cov0" title="0">
                return "Stable"</span>
        case GroupStatePreparingRebalance:<span class="cov0" title="0">
                return "PreparingRebalance"</span>
        case GroupStateCompletingRebalance:<span class="cov0" title="0">
                return "CompletingRebalance"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// OffsetCommit 提交的offset信息
type OffsetCommit struct {
        Topic     string    `json:"topic"`
        Partition int32     `json:"partition"`
        Offset    int64     `json:"offset"`
        Metadata  string    `json:"metadata"`
        Timestamp time.Time `json:"timestamp"`
}

// ConsumerGroupManager 消费者组管理器
type ConsumerGroupManager struct {
        groups  map[string]*ConsumerGroup // 消费者组
        offsets map[string]*OffsetStorage // offset存储 groupID -&gt; OffsetStorage
        mu      sync.RWMutex
}

// OffsetStorage offset存储
type OffsetStorage struct {
        GroupID string                             `json:"group_id"`
        Offsets map[string]map[int32]*OffsetCommit `json:"offsets"` // Topic -&gt; Partition -&gt; OffsetCommit
        mu      sync.RWMutex
}

// NewConsumerGroupManager 创建消费者组管理器
func NewConsumerGroupManager() *ConsumerGroupManager <span class="cov10" title="8">{
        return &amp;ConsumerGroupManager{
                groups:  make(map[string]*ConsumerGroup),
                offsets: make(map[string]*OffsetStorage),
        }
}</span>

// CreateGroup 创建消费者组
func (cgm *ConsumerGroupManager) CreateGroup(groupID string) *ConsumerGroup <span class="cov0" title="0">{
        cgm.mu.Lock()
        defer cgm.mu.Unlock()

        if group, exists := cgm.groups[groupID]; exists </span><span class="cov0" title="0">{
                return group
        }</span>

        <span class="cov0" title="0">group := &amp;ConsumerGroup{
                ID:         groupID,
                Members:    make(map[string]*Consumer),
                Partitions: make(map[string][]int32),
                State:      GroupStateEmpty,
                Protocol:   "round-robin", // 默认使用轮询分配
                Generation: 0,
                CreatedAt:  time.Now(),
                UpdatedAt:  time.Now(),
        }

        cgm.groups[groupID] = group
        cgm.offsets[groupID] = &amp;OffsetStorage{
                GroupID: groupID,
                Offsets: make(map[string]map[int32]*OffsetCommit),
        }

        return group</span>
}

// GetGroup 获取消费者组
func (cgm *ConsumerGroupManager) GetGroup(groupID string) (*ConsumerGroup, bool) <span class="cov0" title="0">{
        cgm.mu.RLock()
        defer cgm.mu.RUnlock()

        group, exists := cgm.groups[groupID]
        return group, exists
}</span>

// DeleteGroup 删除消费者组
func (cgm *ConsumerGroupManager) DeleteGroup(groupID string) error <span class="cov0" title="0">{
        cgm.mu.Lock()
        defer cgm.mu.Unlock()

        delete(cgm.groups, groupID)
        delete(cgm.offsets, groupID)
        return nil
}</span>

// JoinGroup 加入消费者组
func (cgm *ConsumerGroupManager) JoinGroup(groupID, consumerID, clientID string, topics []string, sessionTimeout time.Duration) (*Consumer, error) <span class="cov0" title="0">{
        group := cgm.CreateGroup(groupID)

        group.mu.Lock()
        defer group.mu.Unlock()

        // 创建消费者
        consumer := &amp;Consumer{
                ID:             consumerID,
                ClientID:       clientID,
                GroupID:        groupID,
                Subscriptions:  topics,
                Assignment:     make(map[string][]int32),
                LastHeartbeat:  time.Now(),
                SessionTimeout: sessionTimeout,
                JoinedAt:       time.Now(),
        }

        // 添加到组中
        group.Members[consumerID] = consumer
        group.UpdatedAt = time.Now()

        // 如果是第一个成员，设为Leader
        if len(group.Members) == 1 </span><span class="cov0" title="0">{
                group.Leader = consumerID
        }</span>

        // 状态变更：触发重平衡
        <span class="cov0" title="0">if group.State == GroupStateStable </span><span class="cov0" title="0">{
                group.State = GroupStatePreparingRebalance
                group.Generation++
        }</span> else<span class="cov0" title="0"> if group.State == GroupStateEmpty </span><span class="cov0" title="0">{
                group.State = GroupStatePreparingRebalance
                group.Generation = 1
        }</span>

        <span class="cov0" title="0">return consumer, nil</span>
}

// LeaveGroup 离开消费者组
func (cgm *ConsumerGroupManager) LeaveGroup(groupID, consumerID string) error <span class="cov0" title="0">{
        group, exists := cgm.GetGroup(groupID)
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("group %s not found", groupID)
        }</span>

        <span class="cov0" title="0">group.mu.Lock()
        defer group.mu.Unlock()

        delete(group.Members, consumerID)
        group.UpdatedAt = time.Now()

        // 如果删除的是Leader，重新选举
        if group.Leader == consumerID &amp;&amp; len(group.Members) &gt; 0 </span><span class="cov0" title="0">{
                for memberID := range group.Members </span><span class="cov0" title="0">{
                        group.Leader = memberID
                        break</span>
                }
        }

        // 状态变更
        <span class="cov0" title="0">if len(group.Members) == 0 </span><span class="cov0" title="0">{
                group.State = GroupStateEmpty
        }</span> else<span class="cov0" title="0"> {
                group.State = GroupStatePreparingRebalance
                group.Generation++
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Heartbeat 心跳
func (cgm *ConsumerGroupManager) Heartbeat(groupID, consumerID string) error <span class="cov0" title="0">{
        group, exists := cgm.GetGroup(groupID)
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("group %s not found", groupID)
        }</span>

        <span class="cov0" title="0">group.mu.Lock()
        defer group.mu.Unlock()

        consumer, exists := group.Members[consumerID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("consumer %s not found in group %s", consumerID, groupID)
        }</span>

        <span class="cov0" title="0">consumer.LastHeartbeat = time.Now()
        return nil</span>
}

// CommitOffset 提交offset
func (cgm *ConsumerGroupManager) CommitOffset(groupID, topic string, partition int32, offset int64, metadata string) error <span class="cov0" title="0">{
        cgm.mu.Lock()
        defer cgm.mu.Unlock()

        offsetStorage, exists := cgm.offsets[groupID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("offset storage for group %s not found", groupID)
        }</span>

        <span class="cov0" title="0">offsetStorage.mu.Lock()
        defer offsetStorage.mu.Unlock()

        if offsetStorage.Offsets[topic] == nil </span><span class="cov0" title="0">{
                offsetStorage.Offsets[topic] = make(map[int32]*OffsetCommit)
        }</span>

        <span class="cov0" title="0">offsetStorage.Offsets[topic][partition] = &amp;OffsetCommit{
                Topic:     topic,
                Partition: partition,
                Offset:    offset,
                Metadata:  metadata,
                Timestamp: time.Now(),
        }

        return nil</span>
}

// GetCommittedOffset 获取已提交的offset
func (cgm *ConsumerGroupManager) GetCommittedOffset(groupID, topic string, partition int32) (int64, bool) <span class="cov0" title="0">{
        cgm.mu.RLock()
        defer cgm.mu.RUnlock()

        offsetStorage, exists := cgm.offsets[groupID]
        if !exists </span><span class="cov0" title="0">{
                return -1, false
        }</span>

        <span class="cov0" title="0">offsetStorage.mu.RLock()
        defer offsetStorage.mu.RUnlock()

        if offsetStorage.Offsets[topic] == nil </span><span class="cov0" title="0">{
                return -1, false
        }</span>

        <span class="cov0" title="0">offsetCommit, exists := offsetStorage.Offsets[topic][partition]
        if !exists </span><span class="cov0" title="0">{
                return -1, false
        }</span>

        <span class="cov0" title="0">return offsetCommit.Offset, true</span>
}

// RebalancePartitions 重平衡分区分配
func (cgm *ConsumerGroupManager) RebalancePartitions(groupID string, topicPartitions map[string][]int32) error <span class="cov0" title="0">{
        group, exists := cgm.GetGroup(groupID)
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("group %s not found", groupID)
        }</span>

        <span class="cov0" title="0">group.mu.Lock()
        defer group.mu.Unlock()

        if group.State != GroupStatePreparingRebalance </span><span class="cov0" title="0">{
                return fmt.Errorf("group %s is not in preparing rebalance state", groupID)
        }</span>

        // 使用轮询算法分配分区
        <span class="cov0" title="0">assignment := cgm.roundRobinAssignment(group.Members, topicPartitions)

        // 更新分配结果
        for consumerID, consumer := range group.Members </span><span class="cov0" title="0">{
                consumer.Assignment = assignment[consumerID]
        }</span>

        <span class="cov0" title="0">group.Partitions = topicPartitions
        group.State = GroupStateStable
        group.UpdatedAt = time.Now()

        return nil</span>
}

// roundRobinAssignment 轮询分区分配算法
func (cgm *ConsumerGroupManager) roundRobinAssignment(members map[string]*Consumer, topicPartitions map[string][]int32) map[string]map[string][]int32 <span class="cov0" title="0">{
        assignment := make(map[string]map[string][]int32)

        // 初始化分配结果
        for consumerID := range members </span><span class="cov0" title="0">{
                assignment[consumerID] = make(map[string][]int32)
        }</span>

        <span class="cov0" title="0">if len(members) == 0 </span><span class="cov0" title="0">{
                return assignment
        }</span>

        // 获取消费者ID列表并排序（保证一致性）
        <span class="cov0" title="0">var consumerIDs []string
        for consumerID := range members </span><span class="cov0" title="0">{
                consumerIDs = append(consumerIDs, consumerID)
        }</span>

        // 简单排序
        <span class="cov0" title="0">for i := 0; i &lt; len(consumerIDs)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(consumerIDs); j++ </span><span class="cov0" title="0">{
                        if consumerIDs[i] &gt; consumerIDs[j] </span><span class="cov0" title="0">{
                                consumerIDs[i], consumerIDs[j] = consumerIDs[j], consumerIDs[i]
                        }</span>
                }
        }

        // 轮询分配分区
        <span class="cov0" title="0">consumerIndex := 0
        for topic, partitions := range topicPartitions </span><span class="cov0" title="0">{
                for _, partition := range partitions </span><span class="cov0" title="0">{
                        consumerID := consumerIDs[consumerIndex]
                        if assignment[consumerID][topic] == nil </span><span class="cov0" title="0">{
                                assignment[consumerID][topic] = make([]int32, 0)
                        }</span>
                        <span class="cov0" title="0">assignment[consumerID][topic] = append(assignment[consumerID][topic], partition)
                        consumerIndex = (consumerIndex + 1) % len(consumerIDs)</span>
                }
        }

        <span class="cov0" title="0">return assignment</span>
}

// CleanupExpiredConsumers 清理过期的消费者
func (cgm *ConsumerGroupManager) CleanupExpiredConsumers() <span class="cov0" title="0">{
        cgm.mu.Lock()
        defer cgm.mu.Unlock()

        now := time.Now()
        for groupID, group := range cgm.groups </span><span class="cov0" title="0">{
                group.mu.Lock()

                var expiredConsumers []string
                for consumerID, consumer := range group.Members </span><span class="cov0" title="0">{
                        if now.Sub(consumer.LastHeartbeat) &gt; consumer.SessionTimeout </span><span class="cov0" title="0">{
                                expiredConsumers = append(expiredConsumers, consumerID)
                        }</span>
                }

                // 移除过期消费者
                <span class="cov0" title="0">for _, consumerID := range expiredConsumers </span><span class="cov0" title="0">{
                        delete(group.Members, consumerID)
                }</span>

                // 更新组状态
                <span class="cov0" title="0">if len(expiredConsumers) &gt; 0 </span><span class="cov0" title="0">{
                        group.UpdatedAt = now
                        if len(group.Members) == 0 </span><span class="cov0" title="0">{
                                group.State = GroupStateEmpty
                        }</span> else<span class="cov0" title="0"> {
                                group.State = GroupStatePreparingRebalance
                                group.Generation++

                                // 重新选举Leader
                                if group.Leader != "" </span><span class="cov0" title="0">{
                                        found := false
                                        for memberID := range group.Members </span><span class="cov0" title="0">{
                                                if memberID == group.Leader </span><span class="cov0" title="0">{
                                                        found = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                                for memberID := range group.Members </span><span class="cov0" title="0">{
                                                        group.Leader = memberID
                                                        break</span>
                                                }
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">group.mu.Unlock()

                // 如果组为空且超过一定时间，可以考虑删除组
                if group.State == GroupStateEmpty &amp;&amp; now.Sub(group.UpdatedAt) &gt; time.Hour </span><span class="cov0" title="0">{
                        delete(cgm.groups, groupID)
                        delete(cgm.offsets, groupID)
                }</span>
        }
}

// ListGroups 列出所有消费者组
func (cgm *ConsumerGroupManager) ListGroups() []*ConsumerGroup <span class="cov0" title="0">{
        cgm.mu.RLock()
        defer cgm.mu.RUnlock()

        groups := make([]*ConsumerGroup, 0, len(cgm.groups))
        for _, group := range cgm.groups </span><span class="cov0" title="0">{
                groups = append(groups, group)
        }</span>
        <span class="cov0" title="0">return groups</span>
}

// GetGroupState 获取消费者组状态
func (cgm *ConsumerGroupManager) GetGroupState(groupID string) (GroupState, error) <span class="cov0" title="0">{
        group, exists := cgm.GetGroup(groupID)
        if !exists </span><span class="cov0" title="0">{
                return GroupStateEmpty, fmt.Errorf("group %s not found", groupID)
        }</span>

        <span class="cov0" title="0">group.mu.RLock()
        defer group.mu.RUnlock()

        return group.State, nil</span>
}

// GetGroupInfo 获取消费者组信息（带锁保护）
func (cgm *ConsumerGroupManager) GetGroupInfo(groupID string) (*ConsumerGroup, bool, func()) <span class="cov0" title="0">{
        group, exists := cgm.GetGroup(groupID)
        if !exists </span><span class="cov0" title="0">{
                return nil, false, nil
        }</span>

        <span class="cov0" title="0">group.mu.RLock()
        return group, true, func() </span><span class="cov0" title="0">{ group.mu.RUnlock() }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package metadata

import (
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/issac1998/go-queue/internal/compression"
        "github.com/issac1998/go-queue/internal/deduplication"
        "github.com/issac1998/go-queue/internal/storage"
)

// Manager defines the manager of the message queue system
type Manager struct {
        Config *Config
        // preserver for cluster
        IsRunning bool

        Topics     map[string]*Topic
        Partitions map[string]*Partition
        Segments   map[string]*storage.Segment

        mu sync.RWMutex

        ctx           context.Context
        cancel        context.CancelFunc
        cleanupTicker *time.Ticker
        flushTicker   *time.Ticker

        Stats *SystemStats

        Metrics *Metrics

        // Compression and deduplication features
        Compressor           compression.Compressor
        Deduplicator         *deduplication.Deduplicator
        CompressionEnabled   bool
        DeduplicationEnabled bool

        // Consumer Groups
        ConsumerGroups *ConsumerGroupManager
}

type TopicConfig struct {
        Partitions int32
        Replicas   int32
}

type Config struct {
        DataDir            string        `json:"data_dir"`
        MaxTopicPartitions int           `json:"max_topic_partitions"`
        SegmentSize        int64         `json:"segment_size"`
        RetentionTime      time.Duration `json:"retention_time"`
        MaxStorageSize     int64         `json:"max_storage_size"`

        FlushInterval   time.Duration `json:"flush_interval"`
        CleanupInterval time.Duration `json:"cleanup_interval"`
        MaxMessageSize  int           `json:"max_message_size"`

        // Compression configuration
        CompressionEnabled   bool                        `json:"compression_enabled"`
        CompressionType      compression.CompressionType `json:"compression_type"`
        CompressionThreshold int                         `json:"compression_threshold"` // Compress only messages above this byte count

        // Deduplication configuration
        DeduplicationEnabled bool                  `json:"deduplication_enabled"`
        DeduplicationConfig  *deduplication.Config `json:"deduplication_config"`
}

// SystemStats system statistics
type SystemStats struct {
        mu sync.RWMutex

        // Basic statistics
        TotalTopics     int64 `json:"total_topics"`
        TotalPartitions int64 `json:"total_partitions"`
        TotalSegments   int64 `json:"total_segments"`
        TotalMessages   int64 `json:"total_messages"`
        TotalBytes      int64 `json:"total_bytes"`

        // Performance statistics
        MessagesPerSecond float64 `json:"messages_per_second"`
        BytesPerSecond    float64 `json:"bytes_per_second"`
        AvgLatency        float64 `json:"avg_latency"`

        // Time statistics
        StartTime      time.Time     `json:"start_time"`
        LastUpdateTime time.Time     `json:"last_update_time"`
        Uptime         time.Duration `json:"uptime"`
}

// Metrics monitoring metrics
type Metrics struct {
        mu sync.RWMutex

        // Request statistics
        RequestsTotal   int64 `json:"requests_total"`
        RequestsSuccess int64 `json:"requests_success"`
        RequestsFailed  int64 `json:"requests_failed"`

        // Error statistics
        ErrorsTotal  int64            `json:"errors_total"`
        ErrorsByType map[string]int64 `json:"errors_by_type"`

        // Resource usage
        MemoryUsage int64   `json:"memory_usage"`
        DiskUsage   int64   `json:"disk_usage"`
        CPUUsage    float64 `json:"cpu_usage"`
}

// NewManager 创建新的管理器
func NewManager(config *Config) (*Manager, error) <span class="cov7" title="8">{
        // 验证配置
        if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config: %v", err)
        }</span>

        // 创建数据目录
        <span class="cov7" title="8">if err := os.MkdirAll(config.DataDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create data directory failed: %v", err)
        }</span>

        <span class="cov7" title="8">ctx, cancel := context.WithCancel(context.Background())

        // 初始化压缩器
        var compressor compression.Compressor
        if config.CompressionEnabled </span><span class="cov0" title="0">{
                var err error
                compressor, err = compression.GetCompressor(config.CompressionType)
                if err != nil </span><span class="cov0" title="0">{
                        cancel()
                        return nil, fmt.Errorf("create compressor failed: %v", err)
                }</span>
        } else<span class="cov7" title="8"> {
                compressor, _ = compression.GetCompressor(compression.None)
        }</span>

        // 初始化去重器
        <span class="cov7" title="8">var deduplicator *deduplication.Deduplicator
        if config.DeduplicationEnabled </span><span class="cov0" title="0">{
                if config.DeduplicationConfig == nil </span><span class="cov0" title="0">{
                        config.DeduplicationConfig = deduplication.DefaultConfig()
                }</span>
                <span class="cov0" title="0">deduplicator = deduplication.NewDeduplicator(config.DeduplicationConfig)</span>
        }

        <span class="cov7" title="8">manager := &amp;Manager{
                Config:     config,
                Topics:     make(map[string]*Topic),
                Partitions: make(map[string]*Partition),
                Segments:   make(map[string]*storage.Segment),
                ctx:        ctx,
                cancel:     cancel,
                Stats:      &amp;SystemStats{},
                Metrics: &amp;Metrics{
                        ErrorsByType: make(map[string]int64),
                },

                // 压缩和去重功能
                Compressor:           compressor,
                Deduplicator:         deduplicator,
                CompressionEnabled:   config.CompressionEnabled,
                DeduplicationEnabled: config.DeduplicationEnabled,

                // 消费者组管理
                ConsumerGroups: NewConsumerGroupManager(),
        }

        // 初始化统计信息
        manager.Stats.StartTime = time.Now()
        manager.Stats.LastUpdateTime = time.Now()

        return manager, nil</span>
}

// Start 启动管理器
func (m *Manager) Start() error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // 加载现有数据
        if err := m.loadExistingData(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load existing data failed: %v", err)
        }</span>

        // 启动后台任务
        <span class="cov0" title="0">m.startBackgroundTasks()

        return nil</span>
}

// Stop 停止管理器
func (m *Manager) Stop() error <span class="cov7" title="8">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // 停止后台任务
        m.stopBackgroundTasks()

        // 关闭所有资源
        if err := m.closeAllResources(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("close resources failed: %v", err)
        }</span>

        <span class="cov7" title="8">log.Printf("Manager stopped successfully")
        return nil</span>
}

// CreateTopic creat topic
func (m *Manager) CreateTopic(name string, config *TopicConfig) (*Topic, error) <span class="cov7" title="11">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if int(config.Partitions) &gt; m.Config.MaxTopicPartitions </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("partitions %d exceeds max allowed %d", config.Partitions, m.Config.MaxTopicPartitions)
        }</span>

        <span class="cov7" title="10">if _, exists := m.Topics[name]; exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("topic %s already exists", name)
        }</span>

        <span class="cov7" title="9">topic, err := NewTopic(name, config, m.Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create topic failed: %v", err)
        }</span>

        <span class="cov7" title="9">m.Topics[name] = topic
        m.Stats.TotalTopics++

        m.updateStats()

        log.Printf("Topic %s created successfully", name)
        return topic, nil</span>
}

func NewTopic(name string, config *TopicConfig, sysConfig *Config) (*Topic, error) <span class="cov8" title="12">{
        topic := &amp;Topic{
                Name:       name,
                Config:     config,
                Partitions: make(map[int32]*Partition),
        }
        // 创建分区
        for i := int32(0); i &lt; config.Partitions; i++ </span><span class="cov10" title="22">{
                partition, err := NewPartition(i, name, sysConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="22">topic.Partitions[i] = partition</span>
        }
        <span class="cov8" title="12">return topic, nil</span>
}

// GetPartition 获取分区
func (t *Topic) GetPartition(id int32) (*Partition, error) <span class="cov7" title="9">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        p, ok := t.Partitions[id]
        if !ok </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("partition %d not found", id)
        }</span>
        <span class="cov6" title="7">return p, nil</span>
}

// Close 关闭主题（关闭所有分区）
func (t *Topic) Close() error <span class="cov8" title="12">{
        t.mu.Lock()
        defer t.mu.Unlock()
        for _, p := range t.Partitions </span><span class="cov10" title="22">{
                if err := p.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="12">return nil</span>
}

// GetTopic 获取主题
func (m *Manager) GetTopic(name string) (*Topic, error) <span class="cov3" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        topic, exists := m.Topics[name]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("topic %s not found", name)
        }</span>

        <span class="cov1" title="1">return topic, nil</span>
}

// DeleteTopic 删除主题
func (m *Manager) DeleteTopic(name string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        topic, exists := m.Topics[name]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("topic %s not found", name)
        }</span>

        // 关闭主题
        <span class="cov0" title="0">if err := topic.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("close topic failed: %v", err)
        }</span>

        <span class="cov0" title="0">delete(m.Topics, name)
        m.Stats.TotalTopics--

        // 更新统计信息
        m.updateStats()

        log.Printf("Topic %s deleted successfully", name)
        return nil</span>
}

// ListTopics 列出所有主题
func (m *Manager) ListTopics() []string <span class="cov3" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        topics := make([]string, 0, len(m.Topics))
        for name := range m.Topics </span><span class="cov4" title="3">{
                topics = append(topics, name)
        }</span>

        <span class="cov3" title="2">return topics</span>
}

// GetPartition 获取分区
func (m *Manager) GetPartition(topicName string, partitionID int32) (*Partition, error) <span class="cov7" title="10">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        topic, exists := m.Topics[topicName]
        if !exists </span><span class="cov4" title="3">{
                return nil, fmt.Errorf("topic %s not found", topicName)
        }</span>

        <span class="cov6" title="7">partition, err := topic.GetPartition(partitionID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("get partition failed: %v", err)
        }</span>

        <span class="cov6" title="6">return partition, nil</span>
}

// WriteMessage 写入消息
func (m *Manager) WriteMessage(topicName string, partitionID int32, message []byte) (int64, error) <span class="cov6" title="6">{
        // 验证消息大小
        if len(message) &gt; m.Config.MaxMessageSize </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("message too large: %d bytes", len(message))
        }</span>

        // 检查去重
        <span class="cov5" title="5">if m.DeduplicationEnabled &amp;&amp; m.Deduplicator != nil </span><span class="cov0" title="0">{
                // 先获取分区以便获取下一个offset
                partition, err := m.GetPartition(topicName, partitionID)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                // 计算下一个offset
                <span class="cov0" title="0">var nextOffset int64
                if partition.ActiveSeg != nil </span><span class="cov0" title="0">{
                        nextOffset = partition.ActiveSeg.BaseOffset + partition.ActiveSeg.WriteCount
                }</span>

                <span class="cov0" title="0">isDupe, originalOffset, err := m.Deduplicator.IsDuplicate(message, nextOffset)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("去重检查失败: %v", err)
                }</span> else<span class="cov0" title="0"> if isDupe </span><span class="cov0" title="0">{
                        log.Printf("发现重复消息，返回原始offset: %d", originalOffset)
                        return originalOffset, nil
                }</span>
        }

        // 处理压缩
        <span class="cov5" title="5">processedMessage := message
        if m.CompressionEnabled &amp;&amp; len(message) &gt;= m.Config.CompressionThreshold </span><span class="cov0" title="0">{
                compressed, err := compression.CompressMessage(message, m.Config.CompressionType)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("压缩消息失败: %v", err)
                        // 压缩失败时使用原始消息
                }</span> else<span class="cov0" title="0"> {
                        // 只有在压缩效果明显时才使用压缩版本
                        if len(compressed) &lt; len(message)*8/10 </span><span class="cov0" title="0">{ // 压缩率超过20%才使用
                                processedMessage = compressed
                                log.Printf("消息压缩成功: %d -&gt; %d 字节 (压缩率: %.2f%%)",
                                        len(message), len(compressed),
                                        float64(len(compressed))/float64(len(message))*100)
                        }</span>
                }
        }

        <span class="cov5" title="5">partition, err := m.GetPartition(topicName, partitionID)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        // 写入消息
        <span class="cov5" title="4">offset, err := partition.Append(processedMessage)
        if err != nil </span><span class="cov0" title="0">{
                m.recordError("write_failed")
                return 0, fmt.Errorf("write message failed: %v", err)
        }</span>

        // 更新统计信息
        <span class="cov5" title="4">m.recordSuccess()
        m.updateStats()

        return offset, nil</span>
}

// ReadMessage 读取消息
func (m *Manager) ReadMessage(topicName string, partitionID int32, offset int64, maxBytes int32) ([][]byte, int64, error) <span class="cov3" title="2">{
        partition, err := m.GetPartition(topicName, partitionID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">rawMessages, nextOffset, err := partition.Read(offset, maxBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 解压缩消息
        <span class="cov1" title="1">if m.CompressionEnabled </span><span class="cov0" title="0">{
                decompressedMessages := make([][]byte, 0, len(rawMessages))
                for _, rawMsg := range rawMessages </span><span class="cov0" title="0">{
                        // 检查是否是压缩消息（通过查看前5字节的格式）
                        if len(rawMsg) &gt;= 5 </span><span class="cov0" title="0">{
                                decompressed, err := compression.DecompressMessage(rawMsg)
                                if err != nil </span><span class="cov0" title="0">{
                                        // 如果解压失败，可能是未压缩的消息，直接使用原始数据
                                        decompressedMessages = append(decompressedMessages, rawMsg)
                                }</span> else<span class="cov0" title="0"> {
                                        decompressedMessages = append(decompressedMessages, decompressed)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // 太短的消息直接使用原始数据
                                decompressedMessages = append(decompressedMessages, rawMsg)
                        }</span>
                }
                <span class="cov0" title="0">return decompressedMessages, nextOffset, nil</span>
        }

        <span class="cov1" title="1">return rawMessages, nextOffset, nil</span>
}

// GetStats 获取系统统计信息
func (m *Manager) GetStats() *SystemStats <span class="cov3" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // 计算运行时间
        m.Stats.Uptime = time.Since(m.Stats.StartTime)
        m.Stats.LastUpdateTime = time.Now()

        return m.Stats
}</span>

// GetMetrics 获取监控指标
func (m *Manager) GetMetrics() *Metrics <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return m.Metrics
}</span>

// 后台任务相关方法
func (m *Manager) startBackgroundTasks() <span class="cov0" title="0">{
        go m.flushTask()

        go m.cleanupTask()

        go m.statsUpdateTask()

        go m.consumerGroupCleanupTask()

}</span>

func (m *Manager) stopBackgroundTasks() <span class="cov7" title="8">{
        if m.cleanupTicker != nil </span><span class="cov0" title="0">{
                m.cleanupTicker.Stop()
                m.cleanupTicker = nil
        }</span>
        <span class="cov7" title="8">if m.flushTicker != nil </span><span class="cov0" title="0">{
                m.flushTicker.Stop()
                m.flushTicker = nil
        }</span>
        <span class="cov7" title="8">m.cancel()</span>
}

func (m *Manager) cleanupTask() <span class="cov0" title="0">{
        m.mu.Lock()
        m.cleanupTicker = time.NewTicker(m.Config.CleanupInterval)
        ticker := m.cleanupTicker
        m.mu.Unlock()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := m.cleanupExpiredMessages(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Cleanup failed: %v", err)
                        }</span>
                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (m *Manager) statsUpdateTask() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.updateStats()</span>
                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

// 辅助方法
func (m *Manager) loadExistingData() error <span class="cov0" title="0">{
        // 扫描数据目录，加载现有主题和分区
        log.Printf("Loading existing data from %s", m.Config.DataDir)

        // 检查数据目录是否存在
        if _, err := os.Stat(m.Config.DataDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Printf("Data directory %s does not exist, creating...", m.Config.DataDir)
                if err := os.MkdirAll(m.Config.DataDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create data directory failed: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span> // 新目录，无需加载
        }

        // 扫描数据目录下的所有主题
        <span class="cov0" title="0">entries, err := os.ReadDir(m.Config.DataDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read data directory failed: %v", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span> // 跳过文件，只处理目录
                }

                <span class="cov0" title="0">topicName := entry.Name()
                topicPath := filepath.Join(m.Config.DataDir, topicName)

                // 检查是否是有效的主题目录（包含分区目录）
                if err := m.loadTopic(topicName, topicPath); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to load topic %s: %v", topicName, err)
                        continue</span> // 继续加载其他主题
                }
        }

        <span class="cov0" title="0">log.Printf("Loaded %d topics", len(m.Topics))
        return nil</span>
}

// loadTopic 加载单个主题及其分区
func (m *Manager) loadTopic(topicName, topicPath string) error <span class="cov0" title="0">{
        // 扫描主题目录下的分区
        entries, err := os.ReadDir(topicPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read topic directory failed: %v", err)
        }</span>

        // 创建主题
        <span class="cov0" title="0">topic := &amp;Topic{
                Name:       topicName,
                Partitions: make(map[int32]*Partition),
                Config:     &amp;TopicConfig{},
        }

        var partitionCount int32
        for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // 解析分区目录名，格式：partition-{id}
                <span class="cov0" title="0">if !strings.HasPrefix(entry.Name(), "partition-") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">partitionIDStr := strings.TrimPrefix(entry.Name(), "partition-")
                partitionID, err := strconv.ParseInt(partitionIDStr, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Invalid partition directory name: %s", entry.Name())
                        continue</span>
                }

                // 加载分区
                <span class="cov0" title="0">partition, err := m.loadPartition(int32(partitionID), topicName, filepath.Join(topicPath, entry.Name()))
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to load partition %d: %v", partitionID, err)
                        continue</span>
                }

                <span class="cov0" title="0">topic.Partitions[int32(partitionID)] = partition
                partitionCount++</span>
        }

        <span class="cov0" title="0">if partitionCount &gt; 0 </span><span class="cov0" title="0">{
                topic.Config.Partitions = partitionCount
                m.Topics[topicName] = topic
                log.Printf("Loaded topic %s with %d partitions", topicName, partitionCount)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// loadPartition 加载单个分区及其段
func (m *Manager) loadPartition(partitionID int32, topicName, partitionPath string) (*Partition, error) <span class="cov0" title="0">{
        // 扫描分区目录下的段文件
        entries, err := os.ReadDir(partitionPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read partition directory failed: %v", err)
        }</span>

        // 收集段文件
        <span class="cov0" title="0">var segmentFiles []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".log") </span><span class="cov0" title="0">{
                        segmentFiles = append(segmentFiles, entry.Name())
                }</span>
        }

        // 按文件名排序（文件名包含 BaseOffset）
        <span class="cov0" title="0">sort.Strings(segmentFiles)

        // 创建分区
        partition := &amp;Partition{
                ID:         partitionID,
                Topic:      topicName,
                DataDir:    partitionPath,
                Segments:   make(map[int]*storage.Segment),
                MaxSegSize: m.Config.SegmentSize,
                Mu:         sync.RWMutex{},
        }

        // 加载段
        for i, segmentFile := range segmentFiles </span><span class="cov0" title="0">{
                // 从文件名提取 BaseOffset
                baseOffsetStr := strings.TrimSuffix(segmentFile, ".log")
                baseOffset, err := strconv.ParseInt(baseOffsetStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Invalid segment file name: %s", segmentFile)
                        continue</span>
                }

                // 创建段
                <span class="cov0" title="0">segment, err := storage.NewSegment(partitionPath, baseOffset, m.Config.SegmentSize)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to load segment %s: %v", segmentFile, err)
                        continue</span>
                }

                // 添加到分区
                <span class="cov0" title="0">partition.Segments[i] = segment

                // 最后一个段作为活跃段
                if i == len(segmentFiles)-1 </span><span class="cov0" title="0">{
                        partition.ActiveSeg = segment
                }</span>
        }

        <span class="cov0" title="0">if len(partition.Segments) == 0 </span><span class="cov0" title="0">{
                // 如果没有现有段，创建一个新的
                segment, err := storage.NewSegment(partitionPath, 0, m.Config.SegmentSize)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("create initial segment failed: %v", err)
                }</span>
                <span class="cov0" title="0">partition.Segments[0] = segment
                partition.ActiveSeg = segment</span>
        }

        <span class="cov0" title="0">log.Printf("Loaded partition %d with %d segments", partitionID, len(partition.Segments))
        return partition, nil</span>
}

func (m *Manager) closeAllResources() error <span class="cov7" title="8">{
        // 关闭所有主题
        for _, topic := range m.Topics </span><span class="cov7" title="9">{
                if err := topic.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Close topic failed: %v", err)
                }</span>
        }

        // 关闭所有段
        <span class="cov7" title="8">for _, segment := range m.Segments </span><span class="cov0" title="0">{
                if err := segment.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Close segment failed: %v", err)
                }</span>
        }

        <span class="cov7" title="8">return nil</span>
}

func (m *Manager) cleanupExpiredMessages() error <span class="cov0" title="0">{

        m.mu.Lock()
        defer m.mu.Unlock()

        now := time.Now()
        expireBefore := now.Add(-m.Config.RetentionTime)

        for _, topic := range m.Topics </span><span class="cov0" title="0">{
                for _, partition := range topic.Partitions </span><span class="cov0" title="0">{
                        partition.Mu.Lock()
                        for segID, segment := range partition.Segments </span><span class="cov0" title="0">{
                                // 假设 Segment 有 MinTimestamp 字段
                                if segment.MaxTimestamp.Before(expireBefore) </span><span class="cov0" title="0">{
                                        // 整个 Segment 都过期，直接删除
                                        segment.Close() // 先关闭
                                        delete(partition.Segments, segID)
                                        // 你也可以从 m.Segments 里删掉
                                }</span> else<span class="cov0" title="0"> if segment.MinTimestamp.Before(expireBefore) </span><span class="cov0" title="0">{
                                        // 部分过期，清理 segment 内部的过期消息
                                        segment.PurgeBefore(expireBefore)
                                }</span>
                        }
                        <span class="cov0" title="0">partition.Mu.Unlock()</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *Manager) updateStats() <span class="cov8" title="13">{
        m.Stats.mu.Lock()
        defer m.Stats.mu.Unlock()

        totalMessages := int64(0)
        totalBytes := int64(0)
        totalPartitions := int64(0)
        totalSegments := int64(0)

        for _, topic := range m.Topics </span><span class="cov9" title="16">{
                for _, partition := range topic.Partitions </span><span class="cov10" title="22">{
                        totalPartitions++
                        for _, segment := range partition.Segments </span><span class="cov10" title="22">{
                                segment.Mu.RLock()
                                totalSegments++
                                totalBytes += segment.CurrentSize
                                segment.Mu.RUnlock()
                        }</span>
                }
        }

        <span class="cov8" title="13">m.Stats.TotalMessages = totalMessages // 如果能统计消息数
        m.Stats.TotalBytes = totalBytes
        m.Stats.TotalPartitions = totalPartitions
        m.Stats.TotalSegments = totalSegments</span>
}

func (m *Manager) updateMetrics() <span class="cov0" title="0">{
        m.Metrics.mu.Lock()
        defer m.Metrics.mu.Unlock()

        // 更新资源使用情况
        var totalMemoryUsage int64
        var totalDiskUsage int64

        // 计算内存使用（估算）
        for _, topic := range m.Topics </span><span class="cov0" title="0">{
                for _, partition := range topic.Partitions </span><span class="cov0" title="0">{
                        for _, segment := range partition.Segments </span><span class="cov0" title="0">{
                                // 估算内存使用：索引条目 + 当前大小
                                totalMemoryUsage += int64(len(segment.IndexEntries) * 24) // 每个索引条目约24字节
                                totalDiskUsage += segment.CurrentSize
                        }</span>
                }
        }

        <span class="cov0" title="0">m.Metrics.MemoryUsage = totalMemoryUsage
        m.Metrics.DiskUsage = totalDiskUsage

        // 计算CPU使用率（简化实现，实际应该使用系统调用）
        // 这里只是示例，实际实现需要调用系统API
        m.Metrics.CPUUsage = 0.0</span> // 需要实现系统CPU监控
}

func (m *Manager) recordSuccess() <span class="cov5" title="4">{
        m.Metrics.mu.Lock()
        defer m.Metrics.mu.Unlock()

        m.Metrics.RequestsTotal++
        m.Metrics.RequestsSuccess++
}</span>

func (m *Manager) recordError(errorType string) <span class="cov0" title="0">{
        m.Metrics.mu.Lock()
        defer m.Metrics.mu.Unlock()

        m.Metrics.RequestsTotal++
        m.Metrics.RequestsFailed++
        m.Metrics.ErrorsTotal++
        m.Metrics.ErrorsByType[errorType]++
}</span>

func validateConfig(config *Config) error <span class="cov7" title="8">{
        if config.DataDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("data directory is required")
        }</span>
        <span class="cov7" title="8">if config.SegmentSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("segment size must be positive")
        }</span>
        <span class="cov7" title="8">if config.MaxMessageSize &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max message size must be positive")
        }</span>
        <span class="cov7" title="8">return nil</span>
}

func (m *Manager) flushTask() <span class="cov0" title="0">{
        m.mu.Lock()
        m.flushTicker = time.NewTicker(m.Config.FlushInterval)
        ticker := m.flushTicker
        m.mu.Unlock()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.flushAll()</span>
                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (m *Manager) flushAll() <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        for _, topic := range m.Topics </span><span class="cov0" title="0">{
                for _, partition := range topic.Partitions </span><span class="cov0" title="0">{
                        partition.Flush()
                }</span>
        }
}

func (p *Partition) Flush() <span class="cov0" title="0">{
        p.Mu.RLock()
        defer p.Mu.RUnlock()
        for _, segment := range p.Segments </span><span class="cov0" title="0">{
                segment.Sync()
        }</span>
}

// consumerGroupCleanupTask 消费者组清理任务
func (m *Manager) consumerGroupCleanupTask() <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second) // 每30秒检查一次
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.ConsumerGroups.CleanupExpiredConsumers()</span>
                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package metadata

import (
        "encoding/binary"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/issac1998/go-queue/internal/storage"
)

const (
        DefaultSegmentSize = 1 &lt;&lt; 30
        DefaultPartitions  = 1
)

// Topic defines a topic
type Topic struct {
        Name       string
        Partitions map[int32]*Partition
        Config     *TopicConfig
        mu         sync.RWMutex
}

// Partition defines a partition
type Partition struct {
        ID         int32
        Topic      string
        DataDir    string
        Segments   map[int]*storage.Segment
        ActiveSeg  *storage.Segment
        MaxSegSize int64
        Mu         sync.RWMutex
}

// NewPartition creates a new partition
func NewPartition(id int32, topic string, sysConfig *Config) (*Partition, error) <span class="cov10" title="26">{
        dataDir := filepath.Join(sysConfig.DataDir, topic, fmt.Sprintf("partition-%d", id))
        if err := os.MkdirAll(dataDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create partition dir failed: %v", err)
        }</span>

        <span class="cov10" title="26">seg, err := storage.NewSegment(dataDir, 0, sysConfig.SegmentSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create segment failed: %v", err)
        }</span>

        <span class="cov10" title="26">p := &amp;Partition{
                ID:         id,
                Topic:      topic,
                DataDir:    dataDir,
                Segments:   map[int]*storage.Segment{0: seg},
                ActiveSeg:  seg,
                MaxSegSize: sysConfig.SegmentSize,
                Mu:         sync.RWMutex{},
        }
        return p, nil</span>
}

var (
        topics     = make(map[string]*Topic)
        topicsLock sync.RWMutex
)

// CreateTopic creates a new topic
func CreateTopic(name string, numPartitions int32, dataDir string) (*Topic, error) <span class="cov0" title="0">{
        topicsLock.Lock()
        defer topicsLock.Unlock()

        if _, exists := topics[name]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("topic %s already exists", name)
        }</span>

        <span class="cov0" title="0">topic := &amp;Topic{
                Name:       name,
                Partitions: make(map[int32]*Partition),
        }

        for i := int32(0); i &lt; numPartitions; i++ </span><span class="cov0" title="0">{
                partition, err := createPartition(name, i, dataDir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("create partition %d failed: %v", i, err)
                }</span>
                <span class="cov0" title="0">topic.Partitions[i] = partition</span>
        }

        <span class="cov0" title="0">topics[name] = topic
        return topic, nil</span>
}

// GetTopic retrieves a topic by name
func GetTopic(name string) (*Topic, error) <span class="cov0" title="0">{
        topicsLock.RLock()
        defer topicsLock.RUnlock()

        topic, exists := topics[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("topic %s not found", name)
        }</span>
        <span class="cov0" title="0">return topic, nil</span>
}

func createPartition(topic string, id int32, dataDir string) (*Partition, error) <span class="cov0" title="0">{
        partitionDir := filepath.Join(dataDir, topic, fmt.Sprintf("partition-%d", id))

        segment, err := storage.NewSegment(partitionDir, 0, DefaultSegmentSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create initial segment failed: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;Partition{
                ID:       id,
                Topic:    topic,
                Segments: map[int]*storage.Segment{0: segment},
                DataDir:  partitionDir,
        }, nil</span>
}

// GetPartition defins
func GetPartition(topic string, partitionID int32) (*Partition, error) <span class="cov0" title="0">{
        t, err := GetTopic(topic)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if partitionID &lt; 0 || int(partitionID) &gt;= len(t.Partitions) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid partition ID: %d", partitionID)
        }</span>

        <span class="cov0" title="0">return t.Partitions[partitionID], nil</span>
}

// Close closes the partition and its segments
func (p *Partition) Close() error <span class="cov10" title="26">{
        p.Mu.Lock()
        defer p.Mu.Unlock()

        var errs []error
        for _, segment := range p.Segments </span><span class="cov10" title="26">{
                if err := segment.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov10" title="26">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("close partition failed: %v", errs)
        }</span>
        <span class="cov10" title="26">return nil</span>
}

// Append appends a message to the partition
func (p *Partition) Append(msg []byte) (int64, error) <span class="cov8" title="13">{
        p.Mu.Lock()
        defer p.Mu.Unlock()

        var activeSegment *storage.Segment
        for _, seg := range p.Segments </span><span class="cov8" title="13">{
                activeSegment = seg
                break</span> // TODO: 取任意一个，简化实现
        }

        <span class="cov8" title="13">offset, err := activeSegment.Append(msg, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "segment is full" </span><span class="cov0" title="0">{
                        newSegment, err := storage.NewSegment(
                                p.DataDir,
                                activeSegment.BaseOffset+activeSegment.CurrentSize,
                                DefaultSegmentSize,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("create new segment failed: %v", err)
                        }</span>

                        <span class="cov0" title="0">p.Segments[len(p.Segments)] = newSegment
                        activeSegment = newSegment

                        // retry
                        offset, err = activeSegment.Append(msg, time.Now())
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("append to new segment failed: %v", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return 0, err
                }</span>
        }

        <span class="cov8" title="13">return offset, nil</span>
}

// Read
func (p *Partition) Read(offset int64, maxBytes int32) ([][]byte, int64, error) <span class="cov4" title="3">{
        p.Mu.RLock()
        defer p.Mu.RUnlock()

        var targetSegment *storage.Segment
        for _, segment := range p.Segments </span><span class="cov4" title="3">{
                if offset &gt;= segment.BaseOffset &amp;&amp; offset &lt; segment.BaseOffset+segment.WriteCount </span><span class="cov4" title="3">{
                        targetSegment = segment
                        break</span>
                }
        }

        <span class="cov4" title="3">if targetSegment == nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("offset %d not found", offset)
        }</span>

        <span class="cov4" title="3">pos, err := targetSegment.FindPosition(offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov4" title="3">messages, nextOffset, err := readMessagesFromSegment(targetSegment, pos, int64(maxBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov4" title="3">return messages, nextOffset, nil</span>
}

// readMessagesFromSegment
func readMessagesFromSegment(segment *storage.Segment, startPos int64, maxBytes int64) ([][]byte, int64, error) <span class="cov4" title="3">{
        var messages [][]byte
        currentPos := startPos
        totalBytes := int64(0)
        messageCount := int64(0)
        // read unitils maxBytes or EOF
        for totalBytes &lt; maxBytes </span><span class="cov7" title="11">{
                lenBuf := make([]byte, 4)
                n, err := segment.ReadAt(currentPos, lenBuf)
                if err != nil || n &lt; 4 </span><span class="cov4" title="3">{
                        break</span>
                }

                <span class="cov6" title="8">msgSize := int64(binary.BigEndian.Uint32(lenBuf))
                currentPos += 4

                if msgSize &lt;= 0 || msgSize &gt; maxBytes-totalBytes </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov6" title="8">msgBuf := make([]byte, msgSize)
                n, err = segment.ReadAt(currentPos, msgBuf)
                if err != nil || int64(n) &lt; msgSize </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov6" title="8">messages = append(messages, msgBuf)
                currentPos += msgSize
                totalBytes += msgSize + 4
                messageCount++</span>
        }

        // TODO:Test logic below
        <span class="cov4" title="3">var nextOffset int64
        if messageCount &gt; 0 </span><span class="cov4" title="3">{
                // 找到起始offset，然后加上读取的消息数量
                startOffset := int64(-1)
                for _, entry := range segment.IndexEntries </span><span class="cov4" title="4">{
                        if entry.Position == startPos </span><span class="cov4" title="3">{
                                startOffset = entry.Offset
                                break</span>
                        }
                }

                <span class="cov4" title="3">if startOffset &gt;= 0 </span><span class="cov4" title="3">{
                        nextOffset = startOffset + messageCount
                }</span> else<span class="cov0" title="0"> {
                        // 如果找不到精确的起始位置，基于segment基础offset计算
                        nextOffset = segment.BaseOffset + messageCount
                }</span>
        } else<span class="cov0" title="0"> {
                // 没有读取到消息，返回末尾offset
                nextOffset = segment.BaseOffset + segment.WriteCount
        }</span>

        <span class="cov4" title="3">return messages, nextOffset, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package protocol

import (
        "bytes"
        "encoding/binary"
        "io"
        "log"
        "net"
        "time"

        "github.com/issac1998/go-queue/internal/metadata"
)

// Consumer Group相关的请求类型
const (
        JoinGroupRequestType     = 3
        LeaveGroupRequestType    = 4
        HeartbeatRequestType     = 5
        CommitOffsetRequestType  = 6
        FetchOffsetRequestType   = 7
        ListGroupsRequestType    = 8
        DescribeGroupRequestType = 9
)

// JoinGroupRequest 加入组请求
type JoinGroupRequest struct {
        GroupID        string
        ConsumerID     string
        ClientID       string
        Topics         []string
        SessionTimeout time.Duration
}

// JoinGroupResponse 加入组响应
type JoinGroupResponse struct {
        ErrorCode  int16
        Generation int32
        GroupID    string
        ConsumerID string
        Leader     string
        Members    []GroupMember
        Assignment map[string][]int32 // Topic -&gt; Partitions
}

// GroupMember 组成员信息
type GroupMember struct {
        ID       string
        ClientID string
}

// LeaveGroupRequest 离开组请求
type LeaveGroupRequest struct {
        GroupID    string
        ConsumerID string
}

// LeaveGroupResponse 离开组响应
type LeaveGroupResponse struct {
        ErrorCode int16
}

// HeartbeatRequest 心跳请求
type HeartbeatRequest struct {
        GroupID    string
        ConsumerID string
        Generation int32
}

// HeartbeatResponse 心跳响应
type HeartbeatResponse struct {
        ErrorCode int16
}

// CommitOffsetRequest 提交offset请求
type CommitOffsetRequest struct {
        GroupID   string
        TopicName string
        Partition int32
        Offset    int64
        Metadata  string
}

// CommitOffsetResponse 提交offset响应
type CommitOffsetResponse struct {
        ErrorCode int16
}

// FetchOffsetRequest 获取offset请求
type FetchOffsetRequest struct {
        GroupID   string
        TopicName string
        Partition int32
}

// FetchOffsetResponse 获取offset响应
type FetchOffsetResponse struct {
        ErrorCode int16
        Offset    int64
}

// HandleJoinGroupRequest 处理加入组请求
func HandleJoinGroupRequest(conn net.Conn, manager *metadata.Manager) error <span class="cov0" title="0">{
        // 读取请求数据
        req, err := parseJoinGroupRequest(conn)
        if err != nil </span><span class="cov0" title="0">{
                return sendJoinGroupError(conn, 1) // 协议错误
        }</span>

        <span class="cov0" title="0">log.Printf("Handling JoinGroup request: GroupID=%s, ConsumerID=%s, Topics=%v",
                req.GroupID, req.ConsumerID, req.Topics)

        // 加入消费者组
        consumer, err := manager.ConsumerGroups.JoinGroup(
                req.GroupID, req.ConsumerID, req.ClientID, req.Topics, req.SessionTimeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to join group: %v", err)
                return sendJoinGroupError(conn, 2) // 服务器错误
        }</span>

        // 检查是否需要重平衡
        <span class="cov0" title="0">group, exists, unlock := manager.ConsumerGroups.GetGroupInfo(req.GroupID)
        if !exists </span><span class="cov0" title="0">{
                return sendJoinGroupError(conn, 3) // 组不存在
        }</span>
        <span class="cov0" title="0">needRebalance := group.State == metadata.GroupStatePreparingRebalance
        isLeader := group.Leader == req.ConsumerID
        unlock()

        // 如果需要重平衡且当前消费者是Leader，执行重平衡
        if needRebalance &amp;&amp; isLeader </span><span class="cov0" title="0">{
                topicPartitions := make(map[string][]int32)

                // 获取订阅Topic的分区信息
                for _, topicName := range req.Topics </span><span class="cov0" title="0">{
                        if topic, exists := manager.Topics[topicName]; exists </span><span class="cov0" title="0">{
                                var partitions []int32
                                for partitionID := range topic.Partitions </span><span class="cov0" title="0">{
                                        partitions = append(partitions, partitionID)
                                }</span>
                                <span class="cov0" title="0">topicPartitions[topicName] = partitions</span>
                        }
                }

                <span class="cov0" title="0">err = manager.ConsumerGroups.RebalancePartitions(req.GroupID, topicPartitions)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to rebalance partitions: %v", err)
                }</span>
        }

        // 重新获取组信息（可能已经重平衡）
        <span class="cov0" title="0">group, exists, unlock = manager.ConsumerGroups.GetGroupInfo(req.GroupID)
        if !exists </span><span class="cov0" title="0">{
                return sendJoinGroupError(conn, 3) // 组不存在
        }</span>
        <span class="cov0" title="0">defer unlock()

        // 构建响应
        response := &amp;JoinGroupResponse{
                ErrorCode:  0,
                Generation: group.Generation,
                GroupID:    group.ID,
                ConsumerID: consumer.ID,
                Leader:     group.Leader,
                Assignment: consumer.Assignment,
        }

        // 添加组成员信息
        for _, member := range group.Members </span><span class="cov0" title="0">{
                response.Members = append(response.Members, GroupMember{
                        ID:       member.ID,
                        ClientID: member.ClientID,
                })
        }</span>

        <span class="cov0" title="0">return sendJoinGroupResponse(conn, response)</span>
}

// HandleLeaveGroupRequest 处理离开组请求
func HandleLeaveGroupRequest(conn net.Conn, manager *metadata.Manager) error <span class="cov0" title="0">{
        req, err := parseLeaveGroupRequest(conn)
        if err != nil </span><span class="cov0" title="0">{
                return sendLeaveGroupError(conn, 1)
        }</span>

        <span class="cov0" title="0">log.Printf("Handling LeaveGroup request: GroupID=%s, ConsumerID=%s", req.GroupID, req.ConsumerID)

        err = manager.ConsumerGroups.LeaveGroup(req.GroupID, req.ConsumerID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to leave group: %v", err)
                return sendLeaveGroupError(conn, 2)
        }</span>

        <span class="cov0" title="0">return sendLeaveGroupResponse(conn, &amp;LeaveGroupResponse{ErrorCode: 0})</span>
}

// HandleHeartbeatRequest 处理心跳请求
func HandleHeartbeatRequest(conn net.Conn, manager *metadata.Manager) error <span class="cov0" title="0">{
        req, err := parseHeartbeatRequest(conn)
        if err != nil </span><span class="cov0" title="0">{
                return sendHeartbeatError(conn, 1)
        }</span>

        <span class="cov0" title="0">err = manager.ConsumerGroups.Heartbeat(req.GroupID, req.ConsumerID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Heartbeat failed: %v", err)
                return sendHeartbeatError(conn, 2)
        }</span>

        <span class="cov0" title="0">return sendHeartbeatResponse(conn, &amp;HeartbeatResponse{ErrorCode: 0})</span>
}

// HandleCommitOffsetRequest 处理提交offset请求
func HandleCommitOffsetRequest(conn net.Conn, manager *metadata.Manager) error <span class="cov0" title="0">{
        req, err := parseCommitOffsetRequest(conn)
        if err != nil </span><span class="cov0" title="0">{
                return sendCommitOffsetError(conn, 1)
        }</span>

        <span class="cov0" title="0">log.Printf("Handling CommitOffset request: GroupID=%s, Topic=%s, Partition=%d, Offset=%d",
                req.GroupID, req.TopicName, req.Partition, req.Offset)

        err = manager.ConsumerGroups.CommitOffset(req.GroupID, req.TopicName, req.Partition, req.Offset, req.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to commit offset: %v", err)
                return sendCommitOffsetError(conn, 2)
        }</span>

        <span class="cov0" title="0">return sendCommitOffsetResponse(conn, &amp;CommitOffsetResponse{ErrorCode: 0})</span>
}

// HandleFetchOffsetRequest 处理获取offset请求
func HandleFetchOffsetRequest(conn net.Conn, manager *metadata.Manager) error <span class="cov0" title="0">{
        req, err := parseFetchOffsetRequest(conn)
        if err != nil </span><span class="cov0" title="0">{
                return sendFetchOffsetError(conn, 1, -1)
        }</span>

        <span class="cov0" title="0">offset, exists := manager.ConsumerGroups.GetCommittedOffset(req.GroupID, req.TopicName, req.Partition)
        if !exists </span><span class="cov0" title="0">{
                return sendFetchOffsetError(conn, 3, -1) // Offset不存在
        }</span>

        <span class="cov0" title="0">return sendFetchOffsetResponse(conn, &amp;FetchOffsetResponse{
                ErrorCode: 0,
                Offset:    offset,
        })</span>
}

// 解析请求的函数
func parseJoinGroupRequest(conn net.Conn) (*JoinGroupRequest, error) <span class="cov0" title="0">{
        var version int16
        if err := binary.Read(conn, binary.BigEndian, &amp;version); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取GroupID
        <span class="cov0" title="0">var groupIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;groupIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">groupIDBytes := make([]byte, groupIDLen)
        if _, err := io.ReadFull(conn, groupIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取ConsumerID
        <span class="cov0" title="0">var consumerIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;consumerIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">consumerIDBytes := make([]byte, consumerIDLen)
        if _, err := io.ReadFull(conn, consumerIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取ClientID
        <span class="cov0" title="0">var clientIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;clientIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">clientIDBytes := make([]byte, clientIDLen)
        if _, err := io.ReadFull(conn, clientIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取Topic数量
        <span class="cov0" title="0">var topicCount int32
        if err := binary.Read(conn, binary.BigEndian, &amp;topicCount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">topics := make([]string, topicCount)
        for i := int32(0); i &lt; topicCount; i++ </span><span class="cov0" title="0">{
                var topicLen int16
                if err := binary.Read(conn, binary.BigEndian, &amp;topicLen); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">topicBytes := make([]byte, topicLen)
                if _, err := io.ReadFull(conn, topicBytes); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">topics[i] = string(topicBytes)</span>
        }

        // 读取SessionTimeout
        <span class="cov0" title="0">var sessionTimeoutMs int32
        if err := binary.Read(conn, binary.BigEndian, &amp;sessionTimeoutMs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;JoinGroupRequest{
                GroupID:        string(groupIDBytes),
                ConsumerID:     string(consumerIDBytes),
                ClientID:       string(clientIDBytes),
                Topics:         topics,
                SessionTimeout: time.Duration(sessionTimeoutMs) * time.Millisecond,
        }, nil</span>
}

func parseLeaveGroupRequest(conn net.Conn) (*LeaveGroupRequest, error) <span class="cov0" title="0">{
        var version int16
        if err := binary.Read(conn, binary.BigEndian, &amp;version); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取GroupID
        <span class="cov0" title="0">var groupIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;groupIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">groupIDBytes := make([]byte, groupIDLen)
        if _, err := io.ReadFull(conn, groupIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取ConsumerID
        <span class="cov0" title="0">var consumerIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;consumerIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">consumerIDBytes := make([]byte, consumerIDLen)
        if _, err := io.ReadFull(conn, consumerIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;LeaveGroupRequest{
                GroupID:    string(groupIDBytes),
                ConsumerID: string(consumerIDBytes),
        }, nil</span>
}

func parseHeartbeatRequest(conn net.Conn) (*HeartbeatRequest, error) <span class="cov0" title="0">{
        var version int16
        if err := binary.Read(conn, binary.BigEndian, &amp;version); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取GroupID
        <span class="cov0" title="0">var groupIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;groupIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">groupIDBytes := make([]byte, groupIDLen)
        if _, err := io.ReadFull(conn, groupIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取ConsumerID
        <span class="cov0" title="0">var consumerIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;consumerIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">consumerIDBytes := make([]byte, consumerIDLen)
        if _, err := io.ReadFull(conn, consumerIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取Generation
        <span class="cov0" title="0">var generation int32
        if err := binary.Read(conn, binary.BigEndian, &amp;generation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;HeartbeatRequest{
                GroupID:    string(groupIDBytes),
                ConsumerID: string(consumerIDBytes),
                Generation: generation,
        }, nil</span>
}

func parseCommitOffsetRequest(conn net.Conn) (*CommitOffsetRequest, error) <span class="cov0" title="0">{
        var version int16
        if err := binary.Read(conn, binary.BigEndian, &amp;version); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取GroupID
        <span class="cov0" title="0">var groupIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;groupIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">groupIDBytes := make([]byte, groupIDLen)
        if _, err := io.ReadFull(conn, groupIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取TopicName
        <span class="cov0" title="0">var topicLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;topicLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">topicBytes := make([]byte, topicLen)
        if _, err := io.ReadFull(conn, topicBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取Partition
        <span class="cov0" title="0">var partition int32
        if err := binary.Read(conn, binary.BigEndian, &amp;partition); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取Offset
        <span class="cov0" title="0">var offset int64
        if err := binary.Read(conn, binary.BigEndian, &amp;offset); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取Metadata
        <span class="cov0" title="0">var metadataLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;metadataLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">metadataBytes := make([]byte, metadataLen)
        if _, err := io.ReadFull(conn, metadataBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;CommitOffsetRequest{
                GroupID:   string(groupIDBytes),
                TopicName: string(topicBytes),
                Partition: partition,
                Offset:    offset,
                Metadata:  string(metadataBytes),
        }, nil</span>
}

func parseFetchOffsetRequest(conn net.Conn) (*FetchOffsetRequest, error) <span class="cov0" title="0">{
        var version int16
        if err := binary.Read(conn, binary.BigEndian, &amp;version); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取GroupID
        <span class="cov0" title="0">var groupIDLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;groupIDLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">groupIDBytes := make([]byte, groupIDLen)
        if _, err := io.ReadFull(conn, groupIDBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取TopicName
        <span class="cov0" title="0">var topicLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;topicLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">topicBytes := make([]byte, topicLen)
        if _, err := io.ReadFull(conn, topicBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 读取Partition
        <span class="cov0" title="0">var partition int32
        if err := binary.Read(conn, binary.BigEndian, &amp;partition); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;FetchOffsetRequest{
                GroupID:   string(groupIDBytes),
                TopicName: string(topicBytes),
                Partition: partition,
        }, nil</span>
}

// 发送响应的函数
func sendJoinGroupResponse(conn net.Conn, response *JoinGroupResponse) error <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // ErrorCode
        binary.Write(buf, binary.BigEndian, response.ErrorCode)

        // Generation
        binary.Write(buf, binary.BigEndian, response.Generation)

        // GroupID
        binary.Write(buf, binary.BigEndian, int16(len(response.GroupID)))
        buf.WriteString(response.GroupID)

        // ConsumerID
        binary.Write(buf, binary.BigEndian, int16(len(response.ConsumerID)))
        buf.WriteString(response.ConsumerID)

        // Leader
        binary.Write(buf, binary.BigEndian, int16(len(response.Leader)))
        buf.WriteString(response.Leader)

        // Members count
        binary.Write(buf, binary.BigEndian, int32(len(response.Members)))
        for _, member := range response.Members </span><span class="cov0" title="0">{
                binary.Write(buf, binary.BigEndian, int16(len(member.ID)))
                buf.WriteString(member.ID)
                binary.Write(buf, binary.BigEndian, int16(len(member.ClientID)))
                buf.WriteString(member.ClientID)
        }</span>

        // Assignment
        <span class="cov0" title="0">binary.Write(buf, binary.BigEndian, int32(len(response.Assignment)))
        for topic, partitions := range response.Assignment </span><span class="cov0" title="0">{
                binary.Write(buf, binary.BigEndian, int16(len(topic)))
                buf.WriteString(topic)
                binary.Write(buf, binary.BigEndian, int32(len(partitions)))
                for _, partition := range partitions </span><span class="cov0" title="0">{
                        binary.Write(buf, binary.BigEndian, partition)
                }</span>
        }

        // 发送响应长度和数据
        <span class="cov0" title="0">responseData := buf.Bytes()
        binary.Write(conn, binary.BigEndian, int32(len(responseData)))
        _, err := conn.Write(responseData)
        return err</span>
}

func sendJoinGroupError(conn net.Conn, errorCode int16) error <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, errorCode)
        binary.Write(buf, binary.BigEndian, int32(0)) // Generation
        binary.Write(buf, binary.BigEndian, int16(0)) // Empty GroupID
        binary.Write(buf, binary.BigEndian, int16(0)) // Empty ConsumerID
        binary.Write(buf, binary.BigEndian, int16(0)) // Empty Leader
        binary.Write(buf, binary.BigEndian, int32(0)) // No members
        binary.Write(buf, binary.BigEndian, int32(0)) // No assignment

        responseData := buf.Bytes()
        binary.Write(conn, binary.BigEndian, int32(len(responseData)))
        _, err := conn.Write(responseData)
        return err
}</span>

func sendLeaveGroupResponse(conn net.Conn, response *LeaveGroupResponse) error <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, response.ErrorCode)

        responseData := buf.Bytes()
        binary.Write(conn, binary.BigEndian, int32(len(responseData)))
        _, err := conn.Write(responseData)
        return err
}</span>

func sendLeaveGroupError(conn net.Conn, errorCode int16) error <span class="cov0" title="0">{
        return sendLeaveGroupResponse(conn, &amp;LeaveGroupResponse{ErrorCode: errorCode})
}</span>

func sendHeartbeatResponse(conn net.Conn, response *HeartbeatResponse) error <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, response.ErrorCode)

        responseData := buf.Bytes()
        binary.Write(conn, binary.BigEndian, int32(len(responseData)))
        _, err := conn.Write(responseData)
        return err
}</span>

func sendHeartbeatError(conn net.Conn, errorCode int16) error <span class="cov0" title="0">{
        return sendHeartbeatResponse(conn, &amp;HeartbeatResponse{ErrorCode: errorCode})
}</span>

func sendCommitOffsetResponse(conn net.Conn, response *CommitOffsetResponse) error <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, response.ErrorCode)

        responseData := buf.Bytes()
        binary.Write(conn, binary.BigEndian, int32(len(responseData)))
        _, err := conn.Write(responseData)
        return err
}</span>

func sendCommitOffsetError(conn net.Conn, errorCode int16) error <span class="cov0" title="0">{
        return sendCommitOffsetResponse(conn, &amp;CommitOffsetResponse{ErrorCode: errorCode})
}</span>

func sendFetchOffsetResponse(conn net.Conn, response *FetchOffsetResponse) error <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, response.ErrorCode)
        binary.Write(buf, binary.BigEndian, response.Offset)

        responseData := buf.Bytes()
        binary.Write(conn, binary.BigEndian, int32(len(responseData)))
        _, err := conn.Write(responseData)
        return err
}</span>

func sendFetchOffsetError(conn net.Conn, errorCode int16, offset int64) error <span class="cov0" title="0">{
        return sendFetchOffsetResponse(conn, &amp;FetchOffsetResponse{
                ErrorCode: errorCode,
                Offset:    offset,
        })
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package protocol

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"

        "github.com/issac1998/go-queue/internal/metadata"
        "github.com/issac1998/go-queue/internal/storage"
)

type FetchRequest struct {
        Topic     string
        Partition int32
        Offset    int64
        MaxBytes  int32
}

// FetchResponse
type FetchResponse struct {
        Topic      string
        Partition  int32
        ErrorCode  int16
        Messages   [][]byte
        NextOffset int64
}

// ReadFetchRequest
func ReadFetchRequest(r io.Reader) (*FetchRequest, error) <span class="cov0" title="0">{
        req := &amp;FetchRequest{}

        var version int16
        if err := binary.Read(r, binary.BigEndian, &amp;version); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read protocol version: %v", err)
        }</span>
        <span class="cov0" title="0">if version != CurrentProtocolVersion </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported protocol version: %d", version)
        }</span>

        <span class="cov0" title="0">var topicLen int16
        if err := binary.Read(r, binary.BigEndian, &amp;topicLen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read topic length: %v", err)
        }</span>
        <span class="cov0" title="0">topicBytes := make([]byte, topicLen)
        if _, err := io.ReadFull(r, topicBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read topic: %v", err)
        }</span>
        <span class="cov0" title="0">req.Topic = string(topicBytes)

        if err := binary.Read(r, binary.BigEndian, &amp;req.Partition); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read partition: %v", err)
        }</span>
        <span class="cov0" title="0">if err := binary.Read(r, binary.BigEndian, &amp;req.Offset); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read offset: %v", err)
        }</span>
        <span class="cov0" title="0">if err := binary.Read(r, binary.BigEndian, &amp;req.MaxBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read max bytes: %v", err)
        }</span>

        <span class="cov0" title="0">if req.MaxBytes &gt; MaxFetchBytesLimit </span><span class="cov0" title="0">{
                req.MaxBytes = MaxFetchBytesLimit
        }</span> else<span class="cov0" title="0"> if req.MaxBytes &lt;= 0 </span><span class="cov0" title="0">{
                req.MaxBytes = DefaultMaxFetchBytes
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// WriteFetchResponse
func (res *FetchResponse) Write(w io.Writer) error <span class="cov0" title="0">{
        headerBuf := new(bytes.Buffer)
        binary.Write(headerBuf, binary.BigEndian, int16(len(res.Topic)))
        headerBuf.WriteString(res.Topic)
        binary.Write(headerBuf, binary.BigEndian, res.Partition)
        binary.Write(headerBuf, binary.BigEndian, res.ErrorCode)
        binary.Write(headerBuf, binary.BigEndian, res.NextOffset)
        binary.Write(headerBuf, binary.BigEndian, int32(len(res.Messages))) // 添加消息数量

        var messagesBuf bytes.Buffer
        for _, msg := range res.Messages </span><span class="cov0" title="0">{
                binary.Write(&amp;messagesBuf, binary.BigEndian, int32(len(msg)))
                messagesBuf.Write(msg)
        }</span>

        <span class="cov0" title="0">totalLen := int32(headerBuf.Len() + messagesBuf.Len() + 4)
        if err := binary.Write(w, binary.BigEndian, totalLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := w.Write(headerBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := w.Write(messagesBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleFetchRequest
func HandleFetchRequest(conn io.ReadWriteCloser, manager *metadata.Manager) error <span class="cov0" title="0">{
        defer conn.Close()

        req, err := ReadFetchRequest(conn)
        if err != nil </span><span class="cov0" title="0">{
                return sendFetchError(conn, ErrorInvalidRequest, err.Error())
        }</span>

        <span class="cov0" title="0">messages, nextOffset, err := manager.ReadMessage(req.Topic, req.Partition, req.Offset, req.MaxBytes)
        if err != nil </span><span class="cov0" title="0">{
                return sendFetchError(conn, ErrorOffsetOutOfRange, err.Error())
        }</span>

        <span class="cov0" title="0">response := &amp;FetchResponse{
                Topic:      req.Topic,
                Partition:  req.Partition,
                ErrorCode:  ErrorNone,
                Messages:   messages,
                NextOffset: nextOffset,
        }
        return response.Write(conn)</span>
}

// findSegmentAndPosition
func findSegmentAndPosition(p *metadata.Partition, offset int64) (*storage.Segment, int64, error) <span class="cov0" title="0">{
        for _, seg := range p.Segments </span><span class="cov0" title="0">{
                if offset &gt;= seg.BaseOffset &amp;&amp; offset &lt; seg.BaseOffset+seg.MaxBytes </span><span class="cov0" title="0">{
                        pos, err := seg.FindPosition(offset)
                        return seg, pos, err
                }</span>
        }
        <span class="cov0" title="0">return nil, 0, errors.New("offset out of range")</span>
}

// readMessagesFromSegment
func readMessagesFromSegment(
        seg *storage.Segment,
        startPos int64,
        maxBytes int64,
) ([][]byte, int64, error) <span class="cov0" title="0">{
        var messages [][]byte
        currentPos := startPos
        totalBytes := int64(0)

        for totalBytes &lt; maxBytes </span><span class="cov0" title="0">{
                var msgSize int32
                lenBuf := make([]byte, 4)
                if _, err := seg.ReadAt(currentPos, lenBuf); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, 0, err</span>
                }
                <span class="cov0" title="0">msgSize = int32(binary.BigEndian.Uint32(lenBuf))

                currentPos += 4

                if msgSize &lt;= 0 || int64(msgSize) &gt; (maxBytes-totalBytes) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">msg := make([]byte, msgSize)
                if _, err := seg.ReadAt(currentPos, msg); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">messages = append(messages, msg)
                currentPos += int64(msgSize)
                totalBytes += int64(msgSize) + 4</span>
        }

        <span class="cov0" title="0">return messages, seg.BaseOffset + currentPos, nil</span>
}

// sendFetchError
func sendFetchError(w io.Writer, code int16, message string) error <span class="cov0" title="0">{
        response := &amp;FetchResponse{
                ErrorCode: code,
        }
        if err := response.Write(w); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send error response: %v", err)
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("fetch error %d: %s", code, message)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package protocol

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "net"

        "github.com/issac1998/go-queue/internal/metadata"
)

const (
        // MaxMessageSize defines max message size.
        MaxMessageSize = 1 &lt;&lt; 20
        // CompressionNone decides compress or not
        CompressionNone = 0x00
        // CompressionNone decides compress or not
        FetchRequestType = 0x01

        DefaultMaxFetchBytes = 1 &lt;&lt; 20
        MaxFetchBytesLimit   = 5 &lt;&lt; 20

        CurrentProtocolVersion = 1
)

const (
        ErrorNone = 0

        ErrorInvalidRequest   = 1
        ErrorInvalidTopic     = 2
        ErrorUnknownPartition = 3
        ErrorInvalidMessage   = 4
        ErrorMessageTooLarge  = 5
        ErrorOffsetOutOfRange = 6

        ErrorBrokerNotAvailable = 100
        ErrorFetchFailed        = 101
        ErrorProduceFailed      = 102

        ErrorUnauthorized  = 200
        ErrorQuotaExceeded = 201
)

// ProduceRequest
type ProduceRequest struct {
        Topic       string
        Partition   int32
        Compression int8
        Messages    [][]byte
}

// ProduceResponse
type ProduceResponse struct {
        BaseOffset int64
        ErrorCode  int16
}

// ReadProduceRequest decodes request from network connection
func ReadProduceRequest(r io.Reader) (*ProduceRequest, error) <span class="cov0" title="0">{
        var req ProduceRequest

        var version int16
        if err := binary.Read(r, binary.BigEndian, &amp;version); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read version failed: %v", err)
        }</span>

        // Read topic length and content
        <span class="cov0" title="0">var topicLen int16
        if err := binary.Read(r, binary.BigEndian, &amp;topicLen); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read topic length failed: %v", err)
        }</span>
        <span class="cov0" title="0">topicBytes := make([]byte, topicLen)
        if _, err := io.ReadFull(r, topicBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read topic failed: %v", err)
        }</span>
        <span class="cov0" title="0">req.Topic = string(topicBytes)

        // Read partition and compression
        if err := binary.Read(r, binary.BigEndian, &amp;req.Partition); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read partition failed: %v", err)
        }</span>
        <span class="cov0" title="0">if err := binary.Read(r, binary.BigEndian, &amp;req.Compression); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read compression failed: %v", err)
        }</span>

        // Read message set
        <span class="cov0" title="0">var msgSetSize int32
        if err := binary.Read(r, binary.BigEndian, &amp;msgSetSize); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read message set size failed: %v", err)
        }</span>

        <span class="cov0" title="0">limitedReader := io.LimitReader(r, int64(msgSetSize))
        for </span><span class="cov0" title="0">{
                var msgSize int32
                if err := binary.Read(limitedReader, binary.BigEndian, &amp;msgSize); err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("read message size failed: %v", err)</span>
                }

                <span class="cov0" title="0">if msgSize &gt; MaxMessageSize </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("message size %d exceeds limit %d", msgSize, MaxMessageSize)
                }</span>

                <span class="cov0" title="0">msg := make([]byte, msgSize)
                if _, err := io.ReadFull(limitedReader, msg); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("read message content failed: %v", err)
                }</span>
                <span class="cov0" title="0">req.Messages = append(req.Messages, msg)</span>
        }

        <span class="cov0" title="0">return &amp;req, nil</span>
}

// WriteProduceResponse
func (res *ProduceResponse) Write(w io.Writer) error <span class="cov0" title="0">{
        // 先写入总长度前缀 (8 + 2 = 10 bytes)
        responseLen := int32(8 + 2) // BaseOffset(8) + ErrorCode(2)
        if err := binary.Write(w, binary.BigEndian, responseLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := binary.Write(w, binary.BigEndian, res.BaseOffset); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := binary.Write(w, binary.BigEndian, res.ErrorCode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// HandleProduceRequest
func HandleProduceRequest(conn io.ReadWriter, manager *metadata.Manager, clusterManager interface{}) error <span class="cov0" title="0">{
        req, err := ReadProduceRequest(conn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid produce request: %v", err)
        }</span>

        <span class="cov0" title="0">if req.Topic == "" </span><span class="cov0" title="0">{
                return writeErrorResponse(conn, ErrorInvalidTopic)
        }</span>
        <span class="cov0" title="0">if len(req.Messages) == 0 </span><span class="cov0" title="0">{
                return writeErrorResponse(conn, ErrorInvalidMessage)
        }</span>

        // 如果启用了集群模式，优先使用集群管理器
        <span class="cov0" title="0">if clusterManager != nil </span>{<span class="cov0" title="0">
                // 这里可以添加集群相关的逻辑
                // 目前先使用本地manager
        }</span>

        <span class="cov0" title="0">var firstOffset int64 = -1
        for _, msg := range req.Messages </span><span class="cov0" title="0">{
                offset, err := manager.WriteMessage(req.Topic, req.Partition, msg)
                if err != nil </span><span class="cov0" title="0">{
                        return writeErrorResponse(conn, ErrorMessageTooLarge)
                }</span>
                <span class="cov0" title="0">if firstOffset == -1 </span><span class="cov0" title="0">{
                        firstOffset = offset
                }</span>
        }

        <span class="cov0" title="0">response := &amp;ProduceResponse{
                BaseOffset: firstOffset,
                ErrorCode:  0,
        }
        return response.Write(conn)</span>
}

// writeErrorResponse
func writeErrorResponse(w io.Writer, errorCode int16) error <span class="cov0" title="0">{
        response := &amp;ProduceResponse{
                ErrorCode: errorCode,
        }
        return response.Write(w)
}</span>

func HandleCreateTopicRequest(conn net.Conn, manager *metadata.Manager) <span class="cov0" title="0">{
        var version int16
        if err := binary.Read(conn, binary.BigEndian, &amp;version); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(conn, ErrorInvalidRequest)
                return
        }</span>

        <span class="cov0" title="0">var nameLen int16
        if err := binary.Read(conn, binary.BigEndian, &amp;nameLen); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(conn, ErrorInvalidRequest)
                return
        }</span>

        <span class="cov0" title="0">nameBuf := make([]byte, nameLen)
        if _, err := io.ReadFull(conn, nameBuf); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(conn, ErrorInvalidRequest)
                return
        }</span>
        <span class="cov0" title="0">topicName := string(nameBuf)

        var partitions int32
        if err := binary.Read(conn, binary.BigEndian, &amp;partitions); err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(conn, ErrorInvalidRequest)
                return
        }</span>

        <span class="cov0" title="0">var replicas int32 = 1
        binary.Read(conn, binary.BigEndian, &amp;replicas)

        _, err := manager.CreateTopic(topicName, &amp;metadata.TopicConfig{
                Partitions: partitions,
                Replicas:   replicas,
        })
        if err != nil </span><span class="cov0" title="0">{
                writeErrorResponse(conn, ErrorInvalidRequest)
                return
        }</span>

        <span class="cov0" title="0">writeSuccessResponse(conn)</span>
}

func writeSuccessResponse(conn net.Conn) <span class="cov0" title="0">{
        writeErrorResponse(conn, 0)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package storage

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"
)

const (
        IndexEntrySize = 16   // 8 bytes offset + 8 bytes position
        IndexInterval  = 1024 // Write one index entry per 1KB
)

// Segment
type Segment struct {
        BaseOffset int64
        EndOffset  int64
        MaxBytes   int64
        IsActive   bool

        LogFile       *os.File
        IndexFile     *os.File
        TimeIndexFile *os.File

        DataDir string

        Mu sync.RWMutex

        // cache
        IndexEntries []IndexEntry
        CurrentSize  int64
        LastSynced   int64

        WriteCount    int64
        ReadCount     int64
        LastWriteTime time.Time
        LastReadTime  time.Time

        MinTimestamp time.Time
        MaxTimestamp time.Time
}

// IndexEntry
type IndexEntry struct {
        Offset   int64
        Position int64
        TimeMs   int64
}

// NewSegment creates a new segment
func NewSegment(dir string, baseOffset int64, maxBytes int64) (*Segment, error) <span class="cov7" title="7">{
        // make or create dir and open file
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create directory failed: %v", err)
        }</span>

        <span class="cov7" title="7">logPath := filepath.Join(dir, fmt.Sprintf("%020d.log", baseOffset))
        indexPath := filepath.Join(dir, fmt.Sprintf("%020d.index", baseOffset))
        timeIndexPath := filepath.Join(dir, fmt.Sprintf("%020d.timeindex", baseOffset))

        logFile, err := os.OpenFile(logPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open log file failed: %v", err)
        }</span>

        <span class="cov7" title="7">indexFile, err := os.OpenFile(indexPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                logFile.Close()
                return nil, fmt.Errorf("open index file failed: %v", err)
        }</span>

        <span class="cov7" title="7">timeIndexFile, err := os.OpenFile(timeIndexPath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                logFile.Close()
                indexFile.Close()
                return nil, fmt.Errorf("open time index file failed: %v", err)
        }</span>

        <span class="cov7" title="7">stat, err := logFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                logFile.Close()
                indexFile.Close()
                timeIndexFile.Close()
                return nil, fmt.Errorf("get log file size failed: %v", err)
        }</span>

        <span class="cov7" title="7">segment := &amp;Segment{
                BaseOffset:    baseOffset,
                MaxBytes:      maxBytes,
                IsActive:      true,
                LogFile:       logFile,
                IndexFile:     indexFile,
                TimeIndexFile: timeIndexFile,
                DataDir:       dir,
                CurrentSize:   stat.Size(),
                IndexEntries:  make([]IndexEntry, 0),
                LastWriteTime: time.Now(),
                LastReadTime:  time.Now(),
        }

        // load index to mem
        if err := segment.loadIndex(); err != nil </span><span class="cov0" title="0">{
                segment.Close()
                return nil, fmt.Errorf("load index failed: %v", err)
        }</span>

        // Update WriteCount based on loaded index entries
        <span class="cov7" title="7">if len(segment.IndexEntries) &gt; 0 </span><span class="cov0" title="0">{
                // WriteCount should be equal to the number of index entries
                segment.WriteCount = int64(len(segment.IndexEntries))
                // Update EndOffset
                lastEntry := segment.IndexEntries[len(segment.IndexEntries)-1]
                segment.EndOffset = lastEntry.Offset
        }</span>

        <span class="cov7" title="7">return segment, nil</span>

}

// loadIndex to mem
func (s *Segment) loadIndex() error <span class="cov7" title="7">{
        stat, err := s.IndexFile.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="7">numEntries := stat.Size() / IndexEntrySize
        s.IndexEntries = make([]IndexEntry, 0, numEntries)

        // If the file is empty, return directly
        if stat.Size() == 0 </span><span class="cov7" title="7">{
                return nil
        }</span>

        // Reset file pointer to the beginning
        <span class="cov0" title="0">if _, err := s.IndexFile.Seek(0, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("seek index file failed: %v", err)
        }</span>

        // Read all index entries (only read offset and position)
        <span class="cov0" title="0">for i := int64(0); i &lt; numEntries; i++ </span><span class="cov0" title="0">{
                var entry IndexEntry
                if err := binary.Read(s.IndexFile, binary.BigEndian, &amp;entry.Offset); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("read offset failed at entry %d: %v", i, err)
                }</span>
                <span class="cov0" title="0">if err := binary.Read(s.IndexFile, binary.BigEndian, &amp;entry.Position); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("read position failed at entry %d: %v", i, err)
                }</span>
                // TimeMs field is not read from the index file during loading because it was not stored in old versions
                <span class="cov0" title="0">entry.TimeMs = 0
                s.IndexEntries = append(s.IndexEntries, entry)</span>

        }

        <span class="cov0" title="0">return nil</span>
}

// Append appends a message to the segment
func (s *Segment) Append(msg []byte, timestamp time.Time) (offset int64, err error) <span class="cov10" title="15">{
        s.Mu.Lock()
        defer s.Mu.Unlock()

        if s.CurrentSize+int64(len(msg)+4) &gt; s.MaxBytes </span><span class="cov0" title="0">{
                return 0, errors.New("segment is full")
        }</span>

        // Calculate message offset (using message count, not byte count)
        <span class="cov10" title="15">offset = s.BaseOffset + s.WriteCount

        // Get current file position
        currentFilePos, err := s.LogFile.Seek(0, io.SeekCurrent)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("get file position failed: %v", err)
        }</span>

        // Write message length and content
        <span class="cov10" title="15">if err := binary.Write(s.LogFile, binary.BigEndian, int32(len(msg))); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("write message length failed: %v", err)
        }</span>
        <span class="cov10" title="15">if _, err := s.LogFile.Write(msg); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("write message content failed: %v", err)
        }</span>

        // Force write index entry (index is established for each message)
        <span class="cov10" title="15">if err := binary.Write(s.IndexFile, binary.BigEndian, offset); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("write index offset failed: %v", err)
        }</span>
        <span class="cov10" title="15">if err := binary.Write(s.IndexFile, binary.BigEndian, currentFilePos); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("write index position failed: %v", err)
        }</span>

        // Add to memory index
        <span class="cov10" title="15">entry := IndexEntry{
                Offset:   offset,
                Position: currentFilePos,
                TimeMs:   timestamp.UnixMilli(),
        }
        s.IndexEntries = append(s.IndexEntries, entry)

        // Update timestamp range
        if s.MinTimestamp.IsZero() || timestamp.Before(s.MinTimestamp) </span><span class="cov6" title="6">{
                s.MinTimestamp = timestamp
        }</span>
        <span class="cov10" title="15">if timestamp.After(s.MaxTimestamp) </span><span class="cov10" title="15">{
                s.MaxTimestamp = timestamp
        }</span>

        // Update counters and size
        <span class="cov10" title="15">s.WriteCount++
        s.CurrentSize += int64(len(msg) + 4)
        s.EndOffset = offset

        return offset, nil</span>
}

// FindPosition fidnd message position by offset
func (s *Segment) FindPosition(offset int64) (int64, error) <span class="cov6" title="5">{
        s.Mu.RLock()
        defer s.Mu.RUnlock()

        if offset &lt; s.BaseOffset || offset &gt;= s.BaseOffset+s.WriteCount </span><span class="cov1" title="1">{
                return 0, errors.New("offset out of range")
        }</span>

        // binary search
        <span class="cov5" title="4">left := 0
        right := len(s.IndexEntries) - 1
        var nearestEntry IndexEntry

        for left &lt;= right </span><span class="cov6" title="6">{
                mid := left + (right-left)/2
                if s.IndexEntries[mid].Offset == offset </span><span class="cov5" title="4">{
                        return s.IndexEntries[mid].Position, nil
                }</span> else<span class="cov3" title="2"> if s.IndexEntries[mid].Offset &lt; offset </span><span class="cov1" title="1">{
                        nearestEntry = s.IndexEntries[mid]
                        left = mid + 1
                }</span> else<span class="cov1" title="1"> {
                        right = mid - 1
                }</span>
        }

        <span class="cov0" title="0">if nearestEntry.Offset == 0 </span><span class="cov0" title="0">{
                return s.BaseOffset, nil
                // return 0,nil
        }</span>

        <span class="cov0" title="0">return nearestEntry.Position, nil</span>
}

// ReadAt reads data from a specified position
func (s *Segment) ReadAt(pos int64, buf []byte) (int, error) <span class="cov4" title="3">{
        s.Mu.RLock()
        defer s.Mu.RUnlock()

        if pos &lt; 0 </span><span class="cov0" title="0">{
                return 0, errors.New("invalid position")
        }</span>

        <span class="cov4" title="3">if _, err := s.LogFile.Seek(pos, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("seek failed: %v", err)
        }</span>

        // Read is better to use io.ReadFull to ensure full read
        <span class="cov4" title="3">n, err := s.LogFile.Read(buf)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return n, fmt.Errorf("read failed: %v", err)
        }</span>

        <span class="cov4" title="3">return n, nil</span>
}

// Close closes the Segment
func (s *Segment) Close() error <span class="cov7" title="7">{
        s.Mu.Lock()
        defer s.Mu.Unlock()

        var errs []error

        if s.LogFile != nil </span><span class="cov7" title="7">{
                if err := s.LogFile.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("close log file failed: %v", err))
                }</span>
        }
        <span class="cov7" title="7">if s.IndexFile != nil </span><span class="cov7" title="7">{
                if err := s.IndexFile.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("close index file failed: %v", err))
                }</span>
        }
        <span class="cov7" title="7">if s.TimeIndexFile != nil </span><span class="cov7" title="7">{
                if err := s.TimeIndexFile.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("close time index file failed: %v", err))
                }</span>
        }

        <span class="cov7" title="7">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("close segment failed: %v", errs)
        }</span>
        <span class="cov7" title="7">return nil</span>
}

// Sync synchronizes data to disk
func (s *Segment) Sync() error <span class="cov1" title="1">{
        s.Mu.Lock()
        defer s.Mu.Unlock()

        if err := s.LogFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sync log file failed: %v", err)
        }</span>
        <span class="cov1" title="1">if err := s.IndexFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sync index file failed: %v", err)
        }</span>
        <span class="cov1" title="1">s.LastSynced = s.CurrentSize
        return nil</span>
}

// PurgeBefore removes index entries and (optionally) data before the given time.
// This is a minimal stub; you should implement actual data deletion as needed.
func (s *Segment) PurgeBefore(expireBefore time.Time) <span class="cov1" title="1">{
        s.Mu.Lock()
        defer s.Mu.Unlock()
        newEntries := s.IndexEntries[:0]
        for _, entry := range s.IndexEntries </span><span class="cov5" title="4">{
                if time.UnixMilli(entry.TimeMs).After(expireBefore) </span><span class="cov3" title="2">{
                        newEntries = append(newEntries, entry)
                }</span>
        }
        <span class="cov1" title="1">s.IndexEntries = newEntries
        // Optionally, update MinTimestamp
        if len(s.IndexEntries) &gt; 0 </span><span class="cov1" title="1">{
                s.MinTimestamp = time.UnixMilli(s.IndexEntries[0].TimeMs)
        }</span> else<span class="cov0" title="0"> {
                s.MinTimestamp = time.Time{}
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
